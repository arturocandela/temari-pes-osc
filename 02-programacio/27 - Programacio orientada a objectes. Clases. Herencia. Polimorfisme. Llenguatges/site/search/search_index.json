{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3 Orientada a Objectes (POO)","text":"<p>Aquest material forma part dels recursos did\u00e0ctics del m\u00f2dul Programaci\u00f3, orientat a l\u2019aprenentatge dels fonaments de la Programaci\u00f3 Orientada a Objectes en els Cicles Formatius d\u2019Inform\u00e0tica.</p> <p>El contingut es basa en el tema \u201cProgramaci\u00f3 Orientada a Objectes. Objectes. Classes. Her\u00e8ncia, Polimorfisme. Llenguatges\u201d i est\u00e0 estructurat per oferir una comprensi\u00f3 progressiva i aplicada dels conceptes essencials.</p>"},{"location":"#contacte-docent","title":"\ud83d\udc68\u200d\ud83c\udfeb Contacte docent","text":"<p>Arturo Candela Molt\u00f3 Professor d\u2019Inform\u00e0tica en Cicles Formatius CIPFP Batoi \u2013 Alcoi (Alacant, Comunitat Valenciana)</p> <p>\ud83d\udce7 Correu: a.candelamolto+poo@edu.gva.es \ud83c\udf10 Blog docent: https://portal.edu.gva.es/blogs/s1/arturocandela/</p>"},{"location":"#objectius-generals","title":"\ud83c\udfaf Objectius generals","text":"<p>Aquest material t\u00e9 com a objectiu que l\u2019alumnat:</p> <ul> <li>Comprenga els fonaments conceptuals de la Programaci\u00f3 Orientada a Objectes.</li> <li>S\u00e0piga diferenciar entre objectes, classes i m\u00e8todes, identificant els seus elements.</li> <li>Reconeixca els pilars essencials: encapsulaci\u00f3, abstracci\u00f3, her\u00e8ncia i polimorfisme.</li> <li>Puga aplicar exemples pr\u00e0ctics en Java i entendre la seua equival\u00e8ncia en altres llenguatges (C#, Python, PHP, JavaScript).</li> <li>Desenvolupe una visi\u00f3 cr\u00edtica sobre la reutilitzaci\u00f3, mantenibilitat i organitzaci\u00f3 del codi.</li> </ul>"},{"location":"#metodologia","title":"\ud83d\udcda Metodologia","text":"<p>El curs segueix una seq\u00fc\u00e8ncia did\u00e0ctica basada en la progressi\u00f3 conceptual:</p> <ol> <li>Exploraci\u00f3 te\u00f2rica: lectura guiada amb exemples comentats.</li> <li>Visualitzaci\u00f3: esquemes UML, diagrames i analogies per afavorir la comprensi\u00f3.</li> <li>Pr\u00e0ctica guiada: exercicis amb fragments de codi per completar o modificar.</li> <li>Autoavaluaci\u00f3: q\u00fcestionaris i reptes curts per comprovar la comprensi\u00f3.</li> <li>Discussi\u00f3 i reflexi\u00f3: comparaci\u00f3 entre paradigmes i llenguatges.</li> </ol>"},{"location":"#estructura-del-contingut","title":"\ud83e\uddf1 Estructura del contingut","text":"<p>!!! info \"Qu\u00e8 trobar\u00e0s\"</p> <pre><code>- **Introducci\u00f3 a la OOP**: context hist\u00f2ric i motivaci\u00f3.\n- **Classes i objectes**: atributs, m\u00e8todes, constructors i destructors.\n- **Associacions (Agregaci\u00f3/Composici\u00f3)**: relacions entre objectes.\n- **Els 4 pilars**: encapsulaci\u00f3, abstracci\u00f3, her\u00e8ncia i polimorfisme.\n- **Llenguatges OOP i principis SOLID**: comparativa i bones pr\u00e0ctiques.\n- **Exemple visual (LSP)**: aplicaci\u00f3 del principi de substituci\u00f3 de Liskov.\n- **Exercicis d\u2019autoavaluaci\u00f3**: pr\u00e0ctiques per consolidar els coneixements.\n</code></pre>"},{"location":"#destinataris","title":"\ud83e\udde9 Destinataris","text":"<p>El contingut est\u00e0 pensat per a:</p> <ul> <li>Alumnat de 1r i 2n curs de Cicles Formatius d\u2019Inform\u00e0tica (SMX, ASIX, DAW o DAM).  </li> <li>Persones interessades a iniciar-se en el paradigma orientat a objectes des d\u2019una perspectiva pr\u00e0ctica i pedag\u00f2gica.</li> </ul>"},{"location":"#recomanacions-destudi","title":"\ud83d\udca1 Recomanacions d\u2019estudi","text":"<ul> <li>Llig cada secci\u00f3 amb calma i reprodueix els exemples al teu entorn de treball.  </li> <li>Prova a modificar el codi i observa els efectes en temps d\u2019execuci\u00f3.  </li> <li>Consulta sovint els esquemes UML i les taules de resum.  </li> <li>Practica amb els exercicis del final i comprova si pots explicar cada pilar amb les teues pr\u00f2pies paraules.</li> </ul>"},{"location":"#llicencia-dus","title":"\u2696\ufe0f Llic\u00e8ncia d\u2019\u00fas","text":"<p>Aquest material es publica sota la llic\u00e8ncia Creative Commons Reconeixement-NoComercial-CompartirIgual (CC BY-NC-SA).</p> <p>Pots copiar, reutilitzar i adaptar el contingut sempre que:</p> <ul> <li>cites l\u2019autor (Arturo Candela),</li> <li>no en faces un \u00fas comercial,</li> <li>i compartisques les versions derivades amb la mateixa llic\u00e8ncia.</li> </ul> <p></p> <p>\u201cProgramar \u00e9s ensenyar a pensar a una m\u00e0quina, per\u00f2 aprendre a programar \u00e9s ensenyar-se a pensar a un mateix.\u201d</p> <p>\u2014 Arturo Candela</p>"},{"location":"01-introduccio/","title":"1. Introducci\u00f3","text":"<p>El paradigma de la programaci\u00f3 modular resol problemes dividint-los en un conjunt de funcions que operen sobre dades comunes. A mesura que creix la complexitat, tamb\u00e9 ho fan les interrelacions i l\u2019acoblament entre funcions, cosa que dificulta el manteniment: un canvi local pot afectar altres parts del programa sense que siga trivial detectar-ho. :contentReference[oaicite:0]{index=0}</p> <p>Davant d\u2019aquesta problem\u00e0tica, sorgeix la programaci\u00f3 orientada a objectes (OOP) com a alternativa i complement. En OOP es combinen dades i funcions relacionades dins d\u2019una unitat anomenada objecte. :contentReference[oaicite:1]{index=1}</p> <p>En aquest tema s\u2019estudia qu\u00e8 \u00e9s la OOP i de quins elements es compon; s\u2019exposen els seus pilars fonamentals \u2014encapsulaci\u00f3, abstracci\u00f3, her\u00e8ncia i polimorfisme\u2014 i es revisen els llenguatges de programaci\u00f3 orientats a objectes m\u00e9s utilitzats. Tots els exemples es presenten en Java per ser un llenguatge representatiu del paradigma. :contentReference[oaicite:2]{index=2}</p> <p>La idea b\u00e0sica \u00e9s proporcionar al programador models m\u00e9s pr\u00f2xims al m\u00f3n real que els de la programaci\u00f3 modular; per aix\u00f2, la unitat fonamental \u00e9s l\u2019objecte. :contentReference[oaicite:3]{index=3}</p>"},{"location":"01-introduccio/#11-que-es-veura-al-tema","title":"1.1. Qu\u00e8 es veur\u00e0 al tema","text":"<ul> <li>Classes i objectes: definici\u00f3 d\u2019atributs i m\u00e8todes, difer\u00e8ncia entre membres d\u2019objecte i de classe, i el paper de constructors i destructors (amb menci\u00f3 al garbage collector en Java). :contentReference[oaicite:4]{index=4} :contentReference[oaicite:5]{index=5}  </li> <li>Associacions entre classes, amb especial atenci\u00f3 a agregaci\u00f3 i composici\u00f3. :contentReference[oaicite:6]{index=6}  </li> <li>Els 4 pilars de la OOP:  </li> <li>Encapsulaci\u00f3: unificaci\u00f3 de dades i operacions, i control d\u2019acc\u00e9s als atributs mitjan\u00e7ant modificadors (<code>public</code>, <code>protected</code>, per defecte, <code>private</code>). :contentReference[oaicite:7]{index=7}  </li> <li>Abstracci\u00f3: reducci\u00f3 de la informaci\u00f3 exposada i ocultaci\u00f3 de detalls no rellevants (p. ex., <code>arranca()</code> enmascara la seq\u00fc\u00e8ncia interna d\u2019arrencada). :contentReference[oaicite:8]{index=8}  </li> <li>Her\u00e8ncia: reutilitzaci\u00f3 i especialitzaci\u00f3 via relaci\u00f3 \u201c\u00e9s un\u201d (simple o m\u00faltiple, segons el llenguatge). :contentReference[oaicite:9]{index=9}  </li> <li>Polimorfisme: sobrec\u00e0rrega, sobreescriptura i variables polim\u00f2rfiques. :contentReference[oaicite:10]{index=10}  </li> <li>Llenguatges orientats a objectes m\u00e9s destacats i la seua orientaci\u00f3 dins del paradigma. :contentReference[oaicite:11]{index=11}</li> </ul>"},{"location":"01-introduccio/#12-per-que-oop","title":"1.2. Per qu\u00e8 OOP?","text":"<p>L\u2019objectiu de la OOP \u00e9s reduir la complexitat de les solucions, facilitar la reutilitzaci\u00f3 i acostar els dissenys a conceptes del m\u00f3n real. En organitzar el codi al voltant d\u2019objectes, es millora la mantenibilitat i es disposa d\u2019eines expressives per modelar sistemes amb menor acoblament i major cohesi\u00f3. :contentReference[oaicite:12]{index=12}</p>"},{"location":"02-2-associacions/","title":"2.2. Associacions entre classes","text":"<p>En un sistema orientat a objectes, \u00e9s habitual que una classe no existisca de manera a\u00efllada, sin\u00f3 que es relacione amb altres. Aquesta relaci\u00f3 s\u2019anomena associaci\u00f3 i descriu com uns objectes utilitzen o contenen altres objectes.</p> <p>Per exemple, un Coche pot tindre un conductor i diversos passatgers. Aix\u00f2 implica que existeix una relaci\u00f3 entre les classes <code>Coche</code> i <code>Persona</code>.</p>"},{"location":"02-2-associacions/#221-tipus-dassociacions","title":"2.2.1. Tipus d\u2019associacions","text":""},{"location":"02-2-associacions/#associacio-simple","title":"\ud83d\udd39 Associaci\u00f3 simple","text":"<p>\u00c9s la relaci\u00f3 m\u00e9s b\u00e0sica: una classe fa refer\u00e8ncia a una altra. No implica cap depend\u00e8ncia forta d\u2019exist\u00e8ncia entre els objectes.</p> <pre><code>class Coche {\n    Persona conductor;\n    Persona[] pasajeros;\n}\n\nclass Persona {\n    String DNI;\n    String nombre;\n}\n</code></pre> <p>En aquest cas, <code>Coche</code> coneix a <code>Persona</code>, per\u00f2 <code>Persona</code> pot existir perfectament sense <code>Coche</code>. La relaci\u00f3 \u00e9s de tipus \u201ct\u00e9 un\u201d (has-a).</p>"},{"location":"02-2-associacions/#222-agregacio","title":"2.2.2. Agregaci\u00f3","text":"<p>La agregaci\u00f3 representa una relaci\u00f3 del tipus \u201cpart\u2013tot\u201d feble. Les parts poden existir de manera independent del tot. Aix\u00f2 significa que, si l\u2019objecte contenidor deixa d\u2019existir, els objectes continguts no s\u2019eliminen autom\u00e0ticament.</p> <p>Exemple: una Biblioteca t\u00e9 Llibres. Els llibres poden existir encara que tanque la biblioteca.</p> <pre><code>class Libro {\n    String titulo;\n}\n\nclass Biblioteca {\n    List&lt;Libro&gt; libros = new ArrayList&lt;&gt;();\n}\n</code></pre> <p>Quan s\u2019esborra una inst\u00e0ncia de <code>Biblioteca</code>, els objectes <code>Libro</code> continuen existint en mem\u00f2ria o poden estar referenciats des d\u2019altres parts del programa.</p>"},{"location":"02-2-associacions/#uml-dagregacio-representacio-textual","title":"UML d\u2019agregaci\u00f3 (representaci\u00f3 textual)","text":"<pre><code>Biblioteca &lt;&gt;----- Libro\n</code></pre> <p>El diamant buit (<code>&lt;&gt;</code>) indica agregaci\u00f3, i la fletxa apunta des del tot cap a la part.</p>"},{"location":"02-2-associacions/#223-composicio","title":"2.2.3. Composici\u00f3","text":"<p>La composici\u00f3 \u00e9s una relaci\u00f3 \u201cpart\u2013tot\u201d forta. Les parts no poden existir sense el tot; si l\u2019objecte contenidor s\u2019elimina, tamb\u00e9 desapareixen les seues parts.</p> <p>Exemple: una Casa i les seues Finestres.</p> <pre><code>class Ventana {\n    String material;\n    int ancho, alto;\n}\n\nclass Casa {\n    List&lt;Ventana&gt; ventanas;\n\n    Casa() {\n        ventanas = new ArrayList&lt;&gt;();\n        ventanas.add(new Ventana());\n        ventanas.add(new Ventana());\n    }\n}\n</code></pre> <p>Quan una <code>Casa</code> es destrueix, les seues <code>Ventana</code> deixen d\u2019existir, ja que la seua vida dep\u00e9n directament de la inst\u00e0ncia de <code>Casa</code>.</p>"},{"location":"02-2-associacions/#uml-de-composicio-representacio-textual","title":"UML de composici\u00f3 (representaci\u00f3 textual)","text":"<pre><code>Casa \u25a0----- Ventana\n</code></pre> <p>El diamant ple (<code>\u25a0</code>) indica composici\u00f3, mostrant una depend\u00e8ncia forta.</p>"},{"location":"02-2-associacions/#224-comparativa-entre-agregacio-i-composicio","title":"2.2.4. Comparativa entre agregaci\u00f3 i composici\u00f3","text":"Caracter\u00edstica Agregaci\u00f3 Composici\u00f3 Exist\u00e8ncia de la part Independent del tot Dep\u00e9n del tot Propietat El tot t\u00e9 la part El tot cont\u00e9 i gestiona la part Duraci\u00f3 de vida La part pot sobreviure La part s\u2019elimina amb el tot Exemples t\u00edpics Biblioteca\u2013Llibre, Aula\u2013Alumne Casa\u2013Finestra, Coche\u2013Motor Representaci\u00f3 UML Diamant buit (<code>&lt;&gt;</code>) Diamant ple (<code>\u25a0</code>)"},{"location":"02-2-associacions/#225-exemple-aplicat-relacio-cochemotor","title":"2.2.5. Exemple aplicat: relaci\u00f3 Coche\u2013Motor","text":"<p>Una relaci\u00f3 molt freq\u00fcent en exemples de POO \u00e9s la de composici\u00f3 entre <code>Coche</code> i <code>Motor</code>. El motor no t\u00e9 sentit sense un cotxe concret.</p> <pre><code>class Motor {\n    int potencia;\n\n    Motor(int potencia){\n        this.potencia = potencia;\n    }\n}\n\nclass Coche {\n    private Motor motor; // composici\u00f3\n\n    Coche(){\n        motor = new Motor(120);\n    }\n}\n</code></pre> <p>Quan s\u2019elimina l\u2019objecte <code>Coche</code>, el seu <code>Motor</code> tamb\u00e9 desapareix, ja que forma part intr\u00ednseca de l\u2019estructura interna del cotxe.</p>"},{"location":"02-2-associacions/#226-exemple-dagregacio-cocheconductor","title":"2.2.6. Exemple d\u2019agregaci\u00f3: Coche\u2013Conductor","text":"<p>En canvi, la relaci\u00f3 entre un <code>Coche</code> i un <code>Conductor</code> \u00e9s d\u2019agregaci\u00f3: el conductor pot existir sense dependre del cotxe concret.</p> <pre><code>class Conductor {\n    String nombre;\n    String licencia;\n}\n\nclass Coche {\n    Conductor conductor; // agregaci\u00f3\n\n    Coche(Conductor c){\n        conductor = c;\n    }\n}\n</code></pre> <p>Aix\u00f2 permet que un mateix objecte <code>Conductor</code> puga estar associat a diferents objectes <code>Coche</code> en moments diferents, o que existisca encara que cap cotxe el referencie.</p>"},{"location":"02-2-associacions/#227-altres-tipus-dassociacions","title":"2.2.7. Altres tipus d\u2019associacions","text":"<p>Encara que les m\u00e9s importants s\u00f3n l\u2019agregaci\u00f3 i la composici\u00f3, tamb\u00e9 poden existir altres variants:</p> <ul> <li>Associaci\u00f3 bidireccional: les dues classes es coneixen m\u00fatuament.  </li> <li>Associaci\u00f3 unidireccional: nom\u00e9s una classe coneix l\u2019altra.  </li> <li>Associaci\u00f3 reflexiva: una classe es relaciona amb inst\u00e0ncies d\u2019ella mateixa (p. ex., <code>Empleado</code> supervisa <code>Empleado</code>).  </li> <li>Multiplicitat: indica el nombre d\u2019inst\u00e0ncies implicades en la relaci\u00f3 (<code>1..1</code>, <code>0..*</code>, <code>1..*</code>...).</li> </ul> <p>Exemple de multiplicitat UML textual:</p> <pre><code>Persona 1 ----- * Coche\n</code></pre> <p>Una persona pot tindre molts cotxes, per\u00f2 cada cotxe t\u00e9 exactament una persona propiet\u00e0ria.</p>"},{"location":"02-2-associacions/#228-resum-visual","title":"2.2.8. Resum visual","text":"<pre><code>         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502  Coche     \u2502\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2502 +motor     \u2502\u2500\u2500\u25a0\u2500\u2500&gt; Motor       (Composici\u00f3)\n         \u2502 +conductor \u2502\u2500\u2500&lt;&gt;\u2500&gt; Conductor   (Agregaci\u00f3)\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"02-2-associacions/#229-conclusio","title":"2.2.9. Conclusi\u00f3","text":"<p>Les associacions entre classes permeten modelar la realitat d\u2019un sistema mitjan\u00e7ant relacions entre objectes. Comprendre la difer\u00e8ncia entre agregaci\u00f3 i composici\u00f3 \u00e9s fonamental per dissenyar correctament la jerarquia i depend\u00e8ncia dels components d\u2019una aplicaci\u00f3.</p> <p>\u201cEn OOP, les relacions no sols connecten objectes; defineixen la seua ra\u00f3 d\u2019existir dins del sistema.\u201d</p>"},{"location":"02-classes-objectes/","title":"2. Classes i Objectes","text":"<p>En la programaci\u00f3 orientada a objectes, una classe \u00e9s un model o plantilla que defineix les caracter\u00edstiques (atributs) i comportaments (m\u00e8todes) dels objectes que se\u2019n creen. Cada objecte \u00e9s una inst\u00e0ncia concreta d\u2019aquesta classe, amb valors propis per als seus atributs i capacitat per executar les seues operacions.</p>"},{"location":"02-classes-objectes/#21-exemple-introductori","title":"2.1. Exemple introductori","text":"<p>Considerem l\u2019exemple d\u2019un cotxe. Cada cotxe t\u00e9 atributs com el n\u00famero de bastidor, els quil\u00f2metres totals recorreguts o la quantitat de gasolina. Tamb\u00e9 realitza accions com arrancar, parar o informar del nivell de gasolina.</p> <pre><code>public class Coche {\n    String num_bastidor;\n    float km_totales;\n    float litros_gasolina;\n    boolean en_marcha;\n\n    // Constructor\n    Coche(String bastidor){\n        num_bastidor = bastidor;\n        km_totales = 0;\n        litros_gasolina = 0;\n        en_marcha = false;\n    }\n\n    // M\u00e8todes\n    void arranca(){ en_marcha = true; }\n    void para(){ en_marcha = false; }\n    String getNumeroDeBastidor(){ return num_bastidor; }\n}\n</code></pre> <p>Cada objecte d\u2019aquesta classe (per exemple, dos cotxes diferents) tindr\u00e0 el seu propi estat intern. Aix\u00f2 permet que el programa gestione m\u00faltiples inst\u00e0ncies independents de la mateixa classe.</p>"},{"location":"02-classes-objectes/#22-atributs","title":"2.2. Atributs","text":"<p>Els atributs representen les dades que descriuen l\u2019estat intern d\u2019un objecte. Poden ser de tipus:</p> <ul> <li>Elemental o primitiu, com <code>int</code>, <code>float</code>, <code>boolean</code>, <code>char</code>, etc.  </li> <li>No elemental o complex, com altres classes (<code>Persona</code>, <code>Motor</code>, <code>Ventana</code>...).</li> </ul> <p>En l\u2019exemple anterior, <code>km_totales</code>, <code>litros_gasolina</code> i <code>en_marcha</code> s\u00f3n atributs elementals, mentre que podr\u00edem afegir-ne d\u2019altres no elementals, com ara <code>Motor motorPrincipal</code> o <code>Persona conductor</code>.</p> <pre><code>class Coche {\n    Motor motorPrincipal;\n    Persona conductor;\n}\n</code></pre>"},{"location":"02-classes-objectes/#atributs-dobjecte-i-atributs-de-classe","title":"Atributs d\u2019objecte i atributs de classe","text":"<ul> <li>Atributs d\u2019objecte: cada inst\u00e0ncia en t\u00e9 una c\u00f2pia pr\u00f2pia.   Ex.: <code>km_totales</code> o <code>litros_gasolina</code>.</li> <li>Atributs de classe: es comparteixen entre totes les inst\u00e0ncies.   En Java, es declaren amb la paraula clau <code>static</code>.</li> </ul> <pre><code>class Coche {\n    static int totalCochesFabricados = 0; // atribut de classe\n    String num_bastidor;                   // atribut d\u2019objecte\n\n    Coche(String bastidor){\n        num_bastidor = bastidor;\n        totalCochesFabricados++;\n    }\n}\n</code></pre>"},{"location":"02-classes-objectes/#23-metodes","title":"2.3. M\u00e8todes","text":"<p>Els m\u00e8todes defineixen les accions o comportaments de la classe. Permeten modificar o consultar l\u2019estat dels objectes.</p> <p>L\u2019acc\u00e9s als m\u00e8todes es fa mitjan\u00e7ant l\u2019enviament de missatges:  </p> <pre><code>miCoche.arranca();\nmiCoche.getNumeroDeBastidor();\n</code></pre>"},{"location":"02-classes-objectes/#tipus-de-metodes","title":"Tipus de m\u00e8todes","text":"<ul> <li>M\u00e8todes d\u2019objecte: operen sobre les dades particulars d\u2019una inst\u00e0ncia.  </li> <li>M\u00e8todes de classe: operen a nivell global, i s\u2019accedix sense instanciar cap objecte (<code>NomClasse.m\u00e8tode()</code>).</li> </ul> <pre><code>class Coche {\n    static int totalCoches;\n    void arranca(){ /* ... */ }\n    static void mostrarTotales(){\n        System.out.println(\"S'han fabricat \" + totalCoches + \" cotxes.\");\n    }\n}\n</code></pre>"},{"location":"02-classes-objectes/#24-constructors-i-destructors","title":"2.4. Constructors i Destructors","text":"<p>Els constructors s\u00f3n m\u00e8todes especials que inicialitzen els objectes en el moment de la seua creaci\u00f3. Tenen el mateix nom que la classe i no retornen valor.</p> <pre><code>Coche miCoche = new Coche(\"XF567GH9\");\n</code></pre> <p>En llenguatges com Java, no \u00e9s necessari definir destructors manuals, ja que el garbage collector s\u2019encarrega autom\u00e0ticament de recuperar la mem\u00f2ria d\u2019objectes no utilitzats. En altres llenguatges (com C++), s\u00ed que existeix un destructor expl\u00edcit per gestionar la destrucci\u00f3 i alliberament de recursos.</p>"},{"location":"02-classes-objectes/#25-diagrama-conceptual","title":"2.5. Diagrama conceptual","text":"<pre><code>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502              Coche              \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     \u2502 - num_bastidor: String          \u2502\n     \u2502 - km_totales: float             \u2502\n     \u2502 - litros_gasolina: float        \u2502\n     \u2502 - en_marcha: boolean            \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     \u2502 + Coche(bastidor: String)       \u2502\n     \u2502 + arranca(): void               \u2502\n     \u2502 + para(): void                  \u2502\n     \u2502 + getNumeroDeBastidor(): String \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Aquest diagrama UML representa visualment la definici\u00f3 de la classe <code>Coche</code>, mostrant atributs i m\u00e8todes amb els seus tipus i visibilitat.</p>"},{"location":"02-classes-objectes/#26-objectes-i-instancies","title":"2.6. Objectes i inst\u00e0ncies","text":"<p>Crear un objecte vol dir generar una inst\u00e0ncia d\u2019una classe:</p> <pre><code>Coche cocheDeJuan = new Coche(\"BAS-1324\");\nCoche cocheDeAna  = new Coche(\"CDE-7568\");\n\ncocheDeJuan.arranca();\ncocheDeAna.para();\n</code></pre> <p>Cada objecte mant\u00e9 el seu propi conjunt de valors interns. Encara que els dos siguen del mateix tipus <code>Coche</code>, s\u00f3n entitats independents amb estats distints.</p>"},{"location":"02-classes-objectes/#27-exemple-ampliat-amb-interaccio","title":"2.7. Exemple ampliat amb interacci\u00f3","text":"<pre><code>public class Coche {\n    String num_bastidor;\n    float km_totales;\n    float litros_gasolina;\n    boolean en_marcha;\n\n    Coche(String bastidor){\n        num_bastidor = bastidor;\n        km_totales = 0;\n        litros_gasolina = 10;\n        en_marcha = false;\n    }\n\n    void arranca(){\n        if(litros_gasolina &gt; 0){\n            en_marcha = true;\n            System.out.println(\"El cotxe ha arrencat.\");\n        } else {\n            System.out.println(\"No hi ha gasolina suficient!\");\n        }\n    }\n\n    void conducir(float km){\n        if(en_marcha){\n            km_totales += km;\n            litros_gasolina -= km * 0.1;\n        } else {\n            System.out.println(\"Has d\u2019arrancar el cotxe abans de conduir!\");\n        }\n    }\n\n    void parar(){ en_marcha = false; }\n\n    String getNumeroDeBastidor(){ return num_bastidor; }\n\n    float getNivelGasolina(){ return litros_gasolina; }\n}\n</code></pre> <p>Aquest fragment mostra un comportament m\u00e9s complet: el cotxe necessita gasolina per arrancar, consumeix combustible quan circula, i pot consultar el nivell restant.</p>"},{"location":"02-classes-objectes/#28-resum","title":"2.8. Resum","text":"Concepte Descripci\u00f3 Exemple Classe Plantilla que defineix atributs i m\u00e8todes <code>class Coche { ... }</code> Objecte Inst\u00e0ncia d\u2019una classe <code>Coche miCoche = new Coche(\"A123\");</code> Atribut Dada que descriu l\u2019estat de l\u2019objecte <code>km_totales</code>, <code>litros_gasolina</code> M\u00e8tode Acci\u00f3 que pot realitzar l\u2019objecte <code>arranca()</code>, <code>para()</code> Constructor Inicialitza un objecte nou <code>new Coche(\"B456\")</code> Garbage Collector Gestor autom\u00e0tic de mem\u00f2ria en Java S\u2019executa de manera interna"},{"location":"02-classes-objectes/#29-reflexio-final","title":"2.9. Reflexi\u00f3 final","text":"<p>La separaci\u00f3 entre dades (atributs) i accions (m\u00e8todes) dins d\u2019una mateixa entitat millora la coher\u00e8ncia i redueix els errors per acoblament. La classe proporciona el model i els objectes aporten la vida dins del programa, creant un conjunt organitzat i flexible.</p> <p>\"Una classe \u00e9s la idea; l\u2019objecte \u00e9s la seua manifestaci\u00f3.\"</p>"},{"location":"04-1-principi-liskov/","title":"4.1. Principi de Substituci\u00f3 de Liskov (LSP)","text":"<p>El Principi de Substituci\u00f3 de Liskov \u00e9s un dels pilars del disseny orientat a objectes i forma part dels principis SOLID. Va ser formulat per Barbara Liskov el 1987, i estableix el seg\u00fcent:</p> <p>\u201cLes subclasses han de poder substituir les seues superclasses sense alterar el correcte funcionament del programa.\u201d</p> <p>Aix\u00f2 significa que, si una classe <code>B</code> hereta de <code>A</code>, qualsevol codi que funcione amb objectes de tipus <code>A</code> hauria de funcionar igualment amb objectes de tipus <code>B</code>.</p>"},{"location":"04-1-principi-liskov/#411-significat-practic","title":"4.1.1. Significat pr\u00e0ctic","text":"<p>Quan una subclasse viola el LSP, pot provocar comportaments inesperats, errors o inconsist\u00e8ncies. El principi busca garantir que les relacions d\u2019her\u00e8ncia siguen coherents, \u00e9s a dir, que la subclasse mantinga les expectatives de comportament de la superclasse.</p>"},{"location":"04-1-principi-liskov/#412-exemple-correcte","title":"4.1.2. Exemple correcte","text":"<pre><code>class Vehiculo {\n    public void moure(){\n        System.out.println(\"El vehicle es mou.\");\n    }\n}\n\nclass Cotxe extends Vehiculo {\n    @Override\n    public void moure(){\n        System.out.println(\"El cotxe circula per la carretera.\");\n    }\n}\n\nclass Bicicleta extends Vehiculo {\n    @Override\n    public void moure(){\n        System.out.println(\"La bicicleta pedaleja suaument.\");\n    }\n}\n\npublic class Prova {\n    public static void main(String[] args){\n        Vehiculo v1 = new Cotxe();\n        Vehiculo v2 = new Bicicleta();\n\n        v1.moure();  // El cotxe circula per la carretera.\n        v2.moure();  // La bicicleta pedaleja suaument.\n    }\n}\n</code></pre> <p>Tant <code>Cotxe</code> com <code>Bicicleta</code> poden substituir <code>Vehiculo</code> sense alterar el comportament esperat. Aquest \u00e9s un exemple correcte d\u2019aplicaci\u00f3 del principi de substituci\u00f3.</p>"},{"location":"04-1-principi-liskov/#413-exemple-incorrecte","title":"4.1.3. Exemple incorrecte","text":"<p>Un error com\u00fa \u00e9s crear subclasses que limiten o trenquen el comportament de la superclasse.</p> <pre><code>class Cotxe {\n    public void accelerar(){\n        System.out.println(\"Accelerant amb motor de combusti\u00f3.\");\n    }\n}\n\nclass CotxeElectric extends Cotxe {\n    @Override\n    public void accelerar(){\n        throw new UnsupportedOperationException(\"Els cotxes el\u00e8ctrics no acceleren aix\u00ed!\");\n    }\n}\n</code></pre> <p>En aquest cas, <code>CotxeElectric</code> no respecta el comportament esperat de <code>Cotxe</code>, ja que llan\u00e7a una excepci\u00f3 quan es fa una crida leg\u00edtima a <code>accelerar()</code>. El codi que funcione amb <code>Cotxe</code> deixar\u00e0 de funcionar amb <code>CotxeElectric</code>.</p>"},{"location":"04-1-principi-liskov/#414-regles-basiques-del-lsp","title":"4.1.4. Regles b\u00e0siques del LSP","text":"<p>Perqu\u00e8 una subclasse respecte el principi de Liskov, ha de complir:</p> <ol> <li>Precondicions: no poden ser m\u00e9s restrictives que les de la superclasse.  </li> <li>Postcondicions: no poden ser m\u00e9s febles que les de la superclasse.  </li> <li>Invariants: s\u2019han de mantenir les mateixes regles de consist\u00e8ncia d\u2019estat.  </li> <li>Tipus de retorn: poden ser m\u00e9s espec\u00edfics, per\u00f2 mai incompatibles.  </li> </ol>"},{"location":"04-1-principi-liskov/#415-exemple-visual-lsp","title":"4.1.5. Exemple visual (LSP)","text":"<p>Recordatori del Principi de Substituci\u00f3 de Liskov:</p> <p></p> <p>Aquest mem popular il\u00b7lustra que heretar d\u2019una classe no significa \u201cser una versi\u00f3 modificada\u201d de qualsevol manera, sin\u00f3 ser un tipus substitu\u00efble que mant\u00e9 el contracte original.</p>"},{"location":"04-1-principi-liskov/#416-uml-textual-dexemple","title":"4.1.6. UML textual d\u2019exemple","text":"<pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502   Vehiculo   \u2502\n           \u2502--------------\u2502\n           \u2502 + moure()    \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                           \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Cotxe   \u2502             \u2502  Bicicleta  \u2502\n\u2502----------\u2502             \u2502--------------\u2502\n\u2502 + moure()\u2502             \u2502 + moure()    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>En aquest diagrama, <code>Cotxe</code> i <code>Bicicleta</code> poden ser tractats com a <code>Vehiculo</code> sense alterar la l\u00f2gica de cap programa que use la superclasse.</p>"},{"location":"04-1-principi-liskov/#417-conclusio","title":"4.1.7. Conclusi\u00f3","text":"<p>El principi de Liskov assegura que el sistema siga coherent, ampliable i fiable, ja que impedeix her\u00e8ncies incorrectes o trencades.</p> <p>\u201cSi una subclasse trenca la promesa de la seua superclasse, trenca tamb\u00e9 la confian\u00e7a del programador.\u201d</p>"},{"location":"04-llenguatges/","title":"Llenguatges OOP (m\u00e9s representatius)","text":"<p>Aquest apartat resumeix els principals llenguatges utilitzats en la Programaci\u00f3 Orientada a Objectes (POO) i el seu grau de puresa, paradigma i \u00e0mbit d\u2019aplicaci\u00f3. Aquesta comparaci\u00f3 ajuda a comprendre com s\u2019apliquen els conceptes de classes, her\u00e8ncia, polimorfisme i encapsulaci\u00f3 segons el llenguatge.</p>"},{"location":"04-llenguatges/#java-pur","title":"\ud83d\udfe6 Java (Pur)","text":"<ul> <li>Paradigma: Orientat completament a objectes (encara que admet tipus primitius).  </li> <li>\u00c0mbit: Multiprop\u00f2sit \u2014 aplicacions d\u2019escriptori, servidors, Android, IoT.  </li> <li>Caracter\u00edstiques destacades:  </li> <li>Llenguatge compilat a bytecode, interpretat per la Java Virtual Machine (JVM).  </li> <li>Gran ecosistema d\u2019eines (Spring, Hibernate, Maven).  </li> <li>Gesti\u00f3 autom\u00e0tica de mem\u00f2ria (Garbage Collector).  </li> <li>Fortament tipat i multiplataforma (\u201cWrite Once, Run Anywhere\u201d).  </li> <li>Limitacions: Verbositat en comparaci\u00f3 amb llenguatges din\u00e0mics.</li> </ul>"},{"location":"04-llenguatges/#c-pur","title":"\ud83d\udfe9 C# (Pur)","text":"<ul> <li>Paradigma: Completament orientat a objectes dins de la plataforma .NET.  </li> <li>\u00c0mbit: Escriptori, web, videojocs (Unity), aplicacions m\u00f2bils (MAUI).  </li> <li>Caracter\u00edstiques destacades:  </li> <li>Ecosistema integrat en .NET i Visual Studio.  </li> <li>Suport per a delegates, events i LINQ.  </li> <li>Sintaxi semblant a Java, per\u00f2 amb millores modernes (records, pattern matching).  </li> <li>Limitacions: Depend\u00e8ncia del framework .NET i ecosistema Microsoft, encara que existeix dotnet core per multiplataforma.</li> </ul>"},{"location":"04-llenguatges/#javascript-hibrid","title":"\ud83d\udfe8 JavaScript (H\u00edbrid)","text":"<ul> <li>Paradigma: No \u00e9s un llenguatge purament orientat a objectes, per\u00f2 permet crear classes i her\u00e8ncia amb prototips o la sintaxi <code>class</code>.  </li> <li>\u00c0mbit: Principalment web \u2014 client i servidor (Node.js).  </li> <li>Caracter\u00edstiques destacades:  </li> <li>Model basat en prototips, no en classes tradicionals.  </li> <li>Asincronia i event loop com a base de la seva arquitectura.  </li> <li>\u00c0mplia compatibilitat amb navegadors i frameworks (React, Vue, Angular).  </li> <li>Limitacions: Gesti\u00f3 de tipus feble i comportament din\u00e0mic que pot dificultar grans projectes.</li> </ul>"},{"location":"04-llenguatges/#python-hibrid","title":"\ud83d\udc0d Python (H\u00edbrid)","text":"<ul> <li>Paradigma: Multiparadigma \u2014 suporta POO, per\u00f2 tamb\u00e9 estructurat i funcional.  </li> <li>\u00c0mbit: Cient\u00edfic, IA, backend, automatitzaci\u00f3 i educaci\u00f3.  </li> <li>Caracter\u00edstiques destacades:  </li> <li>Sintaxi senzilla i llegible.  </li> <li>Sistema de tipus din\u00e0mic i duck typing.  </li> <li>Gran comunitat i llibreries (Django, Flask, NumPy).  </li> <li>Her\u00e8ncia m\u00faltiple i mixins com a caracter\u00edstica distintiva.  </li> <li>Limitacions: Rendiment inferior a llenguatges compilats; depend\u00e8ncia de la implementaci\u00f3 (GIL en CPython).</li> </ul>"},{"location":"04-llenguatges/#php-hibrid","title":"\ud83d\udc18 PHP (H\u00edbrid)","text":"<ul> <li>Paradigma: Originalment procedural, per\u00f2 des de PHP5 suporta POO completa.  </li> <li>\u00c0mbit: Principalment aplicacions web del costat servidor.  </li> <li>Caracter\u00edstiques destacades:  </li> <li>Suport per a classes, interf\u00edcies, traits i excepcions.  </li> <li>Integraci\u00f3 amb frameworks moderns (Laravel, Symfony).  </li> <li>Interpretat i \u00e0mpliament desplegat en servidors web.  </li> <li>Facilitat per combinar HTML i codi din\u00e0mic.  </li> <li>Limitacions: Hist\u00f2ricament criticat per incoher\u00e8ncies de disseny i seguretat, encara que les versions modernes ho han millorat.</li> </ul>"},{"location":"04-llenguatges/#comparativa-general","title":"Comparativa general","text":"Llenguatge Tipus Paradigma \u00c0mbit principal Exemple de framework Java Pur POO Multiprop\u00f2sit Spring C# Pur POO .NET, jocs, web ASP.NET, Unity JavaScript H\u00edbrid POO basada en prototips Web (client/servidor) Node.js, React Python H\u00edbrid Multiparadigma IA, backend, educaci\u00f3 Django, Flask PHP H\u00edbrid Procedural i POO Web servidor Laravel, Symfony <p>\u201cCada llenguatge \u00e9s una manera diferent d\u2019expressar els mateixos principis: objectes, missatges i comportament.\u201d</p>"},{"location":"05-conclusio/","title":"5. Conclusi\u00f3","text":"<p>La Programaci\u00f3 Orientada a Objectes (POO) \u00e9s molt m\u00e9s que una t\u00e8cnica de codificaci\u00f3: \u00e9s una manera d\u2019entendre i modelar la realitat dins del programari. El seu objectiu fonamental \u00e9s organitzar les dades i els comportaments en entitats cohesionades anomenades objectes, facilitant aix\u00ed la reutilitzaci\u00f3, l\u2019escalabilitat i la mantenibilitat del codi.</p>"},{"location":"05-conclusio/#51-els-quatre-pilars-fonamentals","title":"5.1. Els quatre pilars fonamentals","text":"<p>Els pilars de la POO \u2014encapsulaci\u00f3, abstracci\u00f3, her\u00e8ncia i polimorfisme\u2014 defineixen com s\u2019estructura el coneixement dins del codi:</p> <ol> <li>Encapsulaci\u00f3 \u2192 protegeix les dades internes i garanteix la integritat dels objectes.  </li> <li>Abstracci\u00f3 \u2192 permet simplificar la complexitat real i centrar-se en el que \u00e9s essencial.  </li> <li>Her\u00e8ncia \u2192 facilita la reutilitzaci\u00f3 del codi i l\u2019especialitzaci\u00f3 de classes.  </li> <li>Polimorfisme \u2192 ofereix flexibilitat per adaptar el comportament segons el context.</li> </ol>"},{"location":"05-conclusio/#52-principis-de-disseny","title":"5.2. Principis de disseny","text":"<p>Els principis SOLID \u2014i especialment el Principi de Substituci\u00f3 de Liskov (LSP)\u2014 ajuden a construir sistemes m\u00e9s coherents i sostenibles en el temps. Aplicar-los correctament evita depend\u00e8ncies r\u00edgides i fomenta un disseny orientat a contractes, on cada classe o interf\u00edcie mant\u00e9 la seua responsabilitat clara.</p>"},{"location":"05-conclusio/#53-llenguatges-i-paradigmes","title":"5.3. Llenguatges i paradigmes","text":"<p>La POO s\u2019aplica en diferents llenguatges, des dels m\u00e9s purs (com Java o C#) fins als h\u00edbrids (com Python o JavaScript). Aquesta varietat demostra que la POO no \u00e9s una religi\u00f3 de sintaxi, sin\u00f3 un conjunt de principis conceptuals adaptables a qualsevol entorn o paradigma.</p>"},{"location":"05-conclusio/#54-loop-com-a-filosofia","title":"5.4. L\u2019OOP com a filosofia","text":"<p>La programaci\u00f3 orientada a objectes no sols estructura el codi, sin\u00f3 tamb\u00e9 el pensament del programador. En lloc de centrar-se en l\u2019ordre d\u2019instruccions, l\u2019OOP ens obliga a pensar en actors, relacions i responsabilitats, aconseguint un enfocament m\u00e9s natural, modular i mantenible.</p>"},{"location":"05-conclusio/#55-tancament","title":"5.5. Tancament","text":"<p>\u201cLa POO no tracta de crear objectes, sin\u00f3 de comprendre\u2019ls.\u201d \u2014 Inspirat en Barbara Liskov i Alan Kay</p> <p>A trav\u00e9s d\u2019aquest curs, s\u2019ha buscat que l\u2019alumnat entenga que darrere de cada classe i cada m\u00e8tode hi ha una decisi\u00f3 de disseny, i que la qualitat del codi no dep\u00e9n del llenguatge, sin\u00f3 de la claredat del pensament.</p> <p>\ud83d\udce7 Autor: Arturo Candela \u2709\ufe0f a.candelamolto+poo@edu.gva.es \ud83c\udf10 Blog docent</p>"},{"location":"06-bibliografia/","title":"6. Bibliografia","text":"<ol> <li> <p>RedMonk \u2013 Language Rankings (2024) https://redmonk.com/sogrady/2024/07/25/language-rankings-2024/    An\u00e0lisi semestral sobre la popularitat dels llenguatges de programaci\u00f3 basada en GitHub i Stack Overflow.</p> </li> <li> <p>Mosh Hamedani \u2013 4 Pillars of Object-Oriented Programming https://codewithmosh.com    Guia clara i moderna sobre els quatre pilars de la POO (Encapsulaci\u00f3, Abstracci\u00f3, Her\u00e8ncia i Polimorfisme).</p> </li> <li> <p>Robert C. Martin \u2013 Clean Code: A Handbook of Agile Software Craftsmanship    Prentice Hall, 2008. ISBN 978-0132350884.    Refer\u00e8ncia fonamental sobre bones pr\u00e0ctiques, responsabilitat \u00fanica i disseny orientat a objectes.</p> </li> <li> <p>Joyanes Aguilar, L. \u2013 Fundamentos de Programaci\u00f3n: Algoritmos, Estructuras de Datos y Objetos    McGraw-Hill, 2017.    Manual introductori complet que aborda la POO des d\u2019una perspectiva educativa.</p> </li> <li> <p>Raoul-Gabriel Urma, Mario Fusco i Alan Mycroft \u2013 Java 8 in Action    Manning Publications, 2014.    Explica conceptes avan\u00e7ats de la POO moderna amb exemples pr\u00e0ctics i orientats a funcions lambda.</p> </li> <li> <p>Oracle \u2013 Java Platform, Standard Edition 21 Documentation https://docs.oracle.com/en/java/javase/21/    Documentaci\u00f3 oficial del llenguatge Java, amb especificacions completes sobre classes, interf\u00edcies i her\u00e8ncia.</p> </li> <li> <p>Barbara Liskov i Jeannette Wing \u2013 Behavioral Subtyping Using Invariants and Constraints Formal Aspects of Computing, Springer, 1994.    Article original que defineix el Principi de Substituci\u00f3 de Liskov (LSP) dins de l\u2019OOP moderna.</p> </li> </ol> <p>\u201cLlegir bons llibres de programaci\u00f3 no ensenya a programar, per\u00f2 ensenya a pensar com un bon programador.\u201d</p>"},{"location":"07-about/","title":"Sobre el projecte","text":"<p>Aquest material forma part del conjunt de recursos educatius per al m\u00f2dul Programaci\u00f3 dels Cicles Formatius d\u2019Inform\u00e0tica de grau mitj\u00e0 i superior. Est\u00e0 pensat per a utilitzar-se en entorns formatius, tant presencials com h\u00edbrids, amb suport de plataformes com Moodle o GitBook.</p>"},{"location":"07-about/#autor","title":"\ud83d\udc68\u200d\ud83c\udfeb Autor","text":"<p>Arturo Candela Professor d\u2019Inform\u00e0tica en Cicles Formatius CIPFP Batoi (Alcoi, Alacant)</p> <p>\ud83d\udce7 Correu electr\u00f2nic: a.candelamolto@edu.gva.es \ud83c\udf10 Blog docent: https://portal.edu.gva.es/blogs/s1/arturocandela/</p>"},{"location":"07-about/#objectiu-del-material","title":"\ud83c\udfaf Objectiu del material","text":"<p>Proporcionar una introducci\u00f3 pr\u00e0ctica i estructurada a la Programaci\u00f3 Orientada a Objectes (POO), incloent-hi:</p> <ul> <li>els conceptes fonamentals de classe, objecte i m\u00e8tode,</li> <li>els 4 pilars: encapsulaci\u00f3, abstracci\u00f3, her\u00e8ncia i polimorfisme,</li> <li>exemples en Java per a comprendre millor la teoria,</li> <li>i exercicis d\u2019autoavaluaci\u00f3 adaptats a l\u2019alumnat de Cicles Formatius.</li> </ul> <p>Aquest material es pot utilitzar com a guia d\u2019estudi, com a suport per a les sessions pr\u00e0ctiques o com a document de consulta per a rep\u00e0s.</p>"},{"location":"07-about/#estructura-de-continguts","title":"\ud83e\udde9 Estructura de continguts","text":"<p>Els continguts estan organitzats de manera progressiva:</p> <ol> <li>Introducci\u00f3 als conceptes b\u00e0sics.  </li> <li>Definici\u00f3 de classes i objectes.  </li> <li>Els pilars de la POO.  </li> <li>Exemples i llenguatges aplicats.  </li> <li>Exercicis d\u2019autoavaluaci\u00f3.  </li> <li>Conclusi\u00f3 i bibliografia.  </li> </ol> <p>A m\u00e9s, la secci\u00f3 Exercicis cont\u00e9 preguntes i reptes dissenyats per consolidar els coneixements adquirits.</p>"},{"location":"07-about/#llicencia","title":"\u2696\ufe0f Llic\u00e8ncia","text":"<p>Aquest material es distribueix sota la llic\u00e8ncia Creative Commons Reconeixement-NoComercial-CompartirIgual (CC BY-NC-SA). Pots reutilitzar, adaptar o compartir el contingut sempre que:</p> <ul> <li>cites l\u2019autor (Arturo Candela),</li> <li>no en faces un \u00fas comercial,</li> <li>i compartisques les versions derivades amb la mateixa llic\u00e8ncia.</li> </ul> <p></p>"},{"location":"07-about/#reconeixements","title":"\ud83d\ude4c Reconeixements","text":"<p>Aquest treball s\u2019ha basat en la preparaci\u00f3 de materials propis per a l\u2019assignatura de Programaci\u00f3 i altres m\u00f2duls de Sistemes Microinform\u00e0tics i Xarxes (SMX). Agra\u00efments especials a l\u2019equip docent del CIPFP Batoi i a l\u2019alumnat per la seua col\u00b7laboraci\u00f3 i feedback constant.</p> <p>\u201cEnsenyar \u00e9s aprendre dues vegades.\u201d \u2014 Joseph Joubert</p>"},{"location":"exercicis/","title":"Exercicis (autoavaluaci\u00f3)","text":"<p>Aquests exercicis et permeten repassar els conceptes principals de la Programaci\u00f3 Orientada a Objectes treballats al llarg del curs. No cal afegir teoria externa: tot es pot respondre utilitzant la informaci\u00f3 del material vist.</p>"},{"location":"exercicis/#1-classe-coche","title":"1) Classe <code>Coche</code>","text":"<ul> <li>Identifica 4 atributs i 4 m\u00e8todes que apareixen als exemples del tema.  </li> <li>Explica si cada atribut seria d\u2019objecte o de classe, i justifica-ho.</li> </ul>"},{"location":"exercicis/#2-encapsulacio-i-modificadors","title":"2) Encapsulaci\u00f3 i modificadors","text":"<ul> <li>A partir de l\u2019exemple <code>Coche.arranca()</code>, indica quins m\u00e8todes haurien de ser <code>private</code> i quin <code>public</code>, i justifica-ho.  </li> <li>Reprodueix la taula d\u2019\u00e0mbits d\u2019acc\u00e9s i marca qu\u00e8 permet cada modificador (<code>public</code>, <code>protected</code>, <code>private</code>, sense especificar).</li> </ul>"},{"location":"exercicis/#3-agregacio-vs-composicio","title":"3) Agregaci\u00f3 vs Composici\u00f3","text":"<ul> <li>Proposa dos parells de classes (p. ex. <code>Biblioteca\u2013Libro</code>, <code>Casa\u2013Ventana</code>).  </li> <li>Explica per qu\u00e8 cada cas representa agregaci\u00f3 o composici\u00f3, segons els criteris del tema (depend\u00e8ncia i cicle de vida).</li> </ul>"},{"location":"exercicis/#4-herencia","title":"4) Her\u00e8ncia","text":"<ul> <li>Dibuixa una jerarquia m\u00ednima amb <code>Vehiculo</code>, <code>Coche</code> i <code>Camion</code>.  </li> <li>Indica un atribut heretat i un m\u00e8tode nou en cada subclasse.</li> </ul>"},{"location":"exercicis/#5-classes-abstractes-vs-interficies","title":"5) Classes abstractes vs Interf\u00edcies","text":"<ul> <li>Escriu una signatura de classe abstracta amb un m\u00e8tode abstracte <code>arranca()</code>.  </li> <li>Implementa una classe concreta que l\u2019herete i definisca el m\u00e8tode.  </li> <li>Crea una interf\u00edcie de remolc i una classe que implemente eixa interf\u00edcie.</li> </ul>"},{"location":"exercicis/#6-polimorfisme","title":"6) Polimorfisme","text":"<p>(a) Escriu dues versions de <code>saludar()</code> (sense i amb par\u00e0metre) i indica per qu\u00e8 \u00e9s un cas de sobrec\u00e0rrega. (b) Redefineix <code>arranca()</code> en <code>Motocicleta</code> i explica per qu\u00e8 \u00e9s una sobreescriptura. (c) Declara <code>Vehiculo v = new Motocicleta();</code> i explica qu\u00e8 \u00e9s una variable polim\u00f2rfica.</p>"},{"location":"exercicis/#7-llenguatges","title":"7) Llenguatges","text":"<ul> <li>Associa cada descripci\u00f3 del tema amb el llenguatge corresponent (Java, C#, JavaScript, Python, PHP).  </li> <li>Escriu un avantatge clau citat al text per a cadascun.</li> </ul> <p>\u201cLa millor manera d\u2019aprendre POO \u00e9s fer que els teus objectes parlen entre ells.\u201d</p>"},{"location":"03-pilars/03-1-encapsulacio/","title":"3.1. Encapsulaci\u00f3","text":"<p>La encapsulaci\u00f3 \u00e9s un dels quatre pilars fonamentals de la programaci\u00f3 orientada a objectes. Consisteix a combinar les dades i les operacions que les manipulen dins d\u2019una mateixa entitat \u2014la classe\u2014 i a restringir l\u2019acc\u00e9s als detalls interns mitjan\u00e7ant modificadors de visibilitat.</p> <p>L\u2019objectiu \u00e9s protegir l\u2019estat intern dels objectes, evitant que siga manipulat directament des de fora de la classe. D\u2019aquesta manera, s\u2019aconseguix controlar com s\u2019accedix i es modifica la informaci\u00f3, i garantir la coher\u00e8ncia del sistema.</p>"},{"location":"03-pilars/03-1-encapsulacio/#311-principi-basic","title":"3.1.1. Principi b\u00e0sic","text":"<p>Un objecte ofereix una interf\u00edcie p\u00fablica amb la qual altres objectes poden interactuar, mentre que els detalls interns de la seua implementaci\u00f3 queden ocults.</p> <p>Aquest principi \u00e9s essencial per aconseguir: * Seguretat: evita modificacions indegudes o inconsistents. * Flexibilitat: permet canviar la implementaci\u00f3 interna sense afectar el codi extern. * Claredat: facilita l\u2019\u00fas de les classes sense con\u00e9ixer el seu funcionament intern.</p>"},{"location":"03-pilars/03-1-encapsulacio/#312-exemple-practic","title":"3.1.2. Exemple pr\u00e0ctic","text":"<pre><code>class Coche {\n    private boolean en_marcha;\n\n    // M\u00e8todes privats (detalls interns)\n    private void abreElFiltroDelAire(){\n        System.out.println(\"Filtre de l\u2019aire obert.\");\n    }\n\n    private void calientaElMotor(){\n        System.out.println(\"Motor en fase de preescalfament.\");\n    }\n\n    // M\u00e8tode p\u00fablic (interf\u00edcie visible)\n    public boolean arranca(){\n        abreElFiltroDelAire();\n        calientaElMotor();\n        en_marcha = true;\n        return en_marcha;\n    }\n}\n</code></pre> <p>En aquest exemple: - Els m\u00e8todes <code>abreElFiltroDelAire()</code> i <code>calientaElMotor()</code> s\u00f3n privats, ja que nom\u00e9s tenen sentit dins del proc\u00e9s d\u2019arrancada del cotxe. - El m\u00e8tode <code>arranca()</code> \u00e9s p\u00fablic perqu\u00e8 forma part de la interf\u00edcie que altres objectes poden utilitzar.</p> <p>Aix\u00f2 assegura que ning\u00fa puga manipular el proc\u00e9s d\u2019arrencada sense passar pels passos correctes establerts pel dissenyador de la classe.</p>"},{"location":"03-pilars/03-1-encapsulacio/#313-modificadors-dacces","title":"3.1.3. Modificadors d\u2019acc\u00e9s","text":"<p>Els modificadors de visibilitat determinen el grau d\u2019accessibilitat dels atributs i m\u00e8todes des d\u2019altres parts del programa. En Java (i en la majoria de llenguatges OOP), s\u2019utilitzen quatre nivells principals:</p> Modificador Accessible dins la classe Accessible dins el paquet Accessible des d\u2019una subclasse Accessible des de fora <code>public</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f <code>protected</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c (sense) (default) \u2714\ufe0f \u2714\ufe0f \u274c \u274c <code>private</code> \u2714\ufe0f \u274c \u274c \u274c <p>\ud83d\udca1 Nota: el modificador sense paraula clau expl\u00edcita (anomenat package-private o default) permet l\u2019acc\u00e9s des de qualsevol classe del mateix paquet, per\u00f2 no des de fora.</p>"},{"location":"03-pilars/03-1-encapsulacio/#314-aplicacio-en-atributs-i-metodes","title":"3.1.4. Aplicaci\u00f3 en atributs i m\u00e8todes","text":"<p>L\u2019encapsulaci\u00f3 s\u2019aplica tant a atributs com a m\u00e8todes.</p>"},{"location":"03-pilars/03-1-encapsulacio/#atributs","title":"Atributs","text":"<p>Solen declarar-se com <code>private</code> per evitar que siguen modificats directament. Per a accedir-hi, s\u2019utilitzen m\u00e8todes d\u2019acc\u00e9s (getters i setters).</p> <pre><code>class Persona {\n    private String nom;\n    private int edat;\n\n    // Getter\n    public String getNom(){\n        return nom;\n    }\n\n    // Setter\n    public void setNom(String nom){\n        this.nom = nom;\n    }\n\n    public int getEdat(){\n        return edat;\n    }\n\n    public void setEdat(int edat){\n        if (edat &gt;= 0){\n            this.edat = edat;\n        }\n    }\n}\n</code></pre> <p>Els setters solen incloure validacions per evitar valors incorrectes (com una edat negativa).</p>"},{"location":"03-pilars/03-1-encapsulacio/#metodes","title":"M\u00e8todes","text":"<p>Els m\u00e8todes que nom\u00e9s tenen sentit dins del context intern de la classe es declaren <code>private</code>, mentre que els que defineixen la interf\u00edcie externa s\u00f3n <code>public</code>.</p>"},{"location":"03-pilars/03-1-encapsulacio/#315-beneficis-de-lencapsulacio","title":"3.1.5. Beneficis de l\u2019encapsulaci\u00f3","text":"<ul> <li>Evita depend\u00e8ncies externes: altres classes no depenen de la implementaci\u00f3 interna.  </li> <li>Millora la mantenibilitat: es poden fer canvis interns sense afectar el codi client.  </li> <li>Augmenta la seguretat del codi: els valors interns no poden ser alterats de manera arbitr\u00e0ria.  </li> <li>Facilita el test i el debug: els errors es localitzen m\u00e9s f\u00e0cilment dins de la classe responsable.</li> </ul>"},{"location":"03-pilars/03-1-encapsulacio/#316-comparacio-visual","title":"3.1.6. Comparaci\u00f3 visual","text":"<pre><code>Sense encapsulaci\u00f3:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Coche       \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 en_marcha    \u2502 \u2190 Accessible directament\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2191\n       \u2502 (manipulaci\u00f3 directa)\n       \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500 Altres classes\n\nAmb encapsulaci\u00f3:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Coche       \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 - en_marcha  \u2502 \u2190 Privat\n    \u2502 + arranca()  \u2502 \u2190 P\u00fablic\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2191\n       \u2502 (acc\u00e9s controlat)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500 Altres classes\n</code></pre>"},{"location":"03-pilars/03-1-encapsulacio/#317-resum-final","title":"3.1.7. Resum final","text":"Concepte Descripci\u00f3 Exemple Encapsulaci\u00f3 Integrar dades i comportament dins d\u2019una mateixa entitat <code>class Coche { private boolean en_marcha; }</code> Acc\u00e9s controlat Evita modificacions externes directes <code>getters</code> i <code>setters</code> Interf\u00edcie p\u00fablica Defineix com altres objectes interactuen amb la classe <code>public void arranca()</code> Privacitat interna Amaga els detalls d\u2019implementaci\u00f3 <code>private void calientaElMotor()</code> <p>\u201cEncapsular \u00e9s oferir nom\u00e9s all\u00f2 que cal, i protegir all\u00f2 que no cal mostrar.\u201d</p>"},{"location":"03-pilars/03-2-abstraccio/","title":"3.2. Abstracci\u00f3","text":"<p>La abstracci\u00f3 \u00e9s el segon pilar fonamental de la programaci\u00f3 orientada a objectes. Consisteix a centrar-se en l\u2019ess\u00e8ncia d\u2019un objecte i amagar els detalls no rellevants per a l\u2019\u00fas que se\u2019n fa.  </p> <p>\u00c9s un mecanisme que permet reduir la complexitat mostrant nom\u00e9s la informaci\u00f3 necess\u00e0ria i ocultant tot el que no cal con\u00e9ixer per a utilitzar una classe.</p>"},{"location":"03-pilars/03-2-abstraccio/#321-idea-clau","title":"3.2.1. Idea clau","text":"<p>L\u2019abstracci\u00f3 \u00e9s el proc\u00e9s de definir qu\u00e8 fa un objecte, sense preocupar-se de com ho fa. Aix\u00f2 permet separar el concepte (l\u2019interf\u00edcie visible) de la implementaci\u00f3 (els detalls interns).</p> <p>\ud83e\udde0 \u201cAbstraure \u00e9s descriure el qu\u00e8 i amagar el com.\u201d</p> <p>Per exemple, per arrancar un cotxe n\u2019hi ha prou amb cridar el m\u00e8tode <code>arranca()</code>. No cal saber quins passos interns realitza el motor, si injecta combustible o si activa components interns. El m\u00e8tode abstrau tot aquest comportament en una \u00fanica operaci\u00f3 d\u2019alt nivell.</p>"},{"location":"03-pilars/03-2-abstraccio/#322-exemple-dabstraccio","title":"3.2.2. Exemple d\u2019abstracci\u00f3","text":"<pre><code>class Coche {\n    private boolean en_marcha;\n\n    public void arranca(){\n        prepararCombustible();\n        activarBateria();\n        girarMotor();\n        en_marcha = true;\n    }\n\n    // Detalls interns (no visibles externament)\n    private void prepararCombustible(){ /* ... */ }\n    private void activarBateria(){ /* ... */ }\n    private void girarMotor(){ /* ... */ }\n}\n</code></pre> <p>Des de fora, l\u2019usuari nom\u00e9s veu:</p> <pre><code>miCoche.arranca();\n</code></pre> <p>Tot el proc\u00e9s t\u00e8cnic (els m\u00e8todes <code>prepararCombustible()</code>, <code>activarBateria()</code>, <code>girarMotor()</code>) queda amagat. Aix\u00ed s\u2019aconsegueix que la interf\u00edcie siga senzilla i intu\u00eftiva, mentre que la implementaci\u00f3 pot evolucionar o canviar sense afectar els usuaris de la classe.</p>"},{"location":"03-pilars/03-2-abstraccio/#323-beneficis-de-labstraccio","title":"3.2.3. Beneficis de l\u2019abstracci\u00f3","text":"<ul> <li>Simplifica la interacci\u00f3 amb els objectes: l\u2019usuari no ha de con\u00e9ixer els detalls interns.  </li> <li>Millora la llegibilitat: el codi \u00e9s m\u00e9s net i expressiu.  </li> <li>Permet el canvi independent: la implementaci\u00f3 pot canviar sense afectar el codi que la utilitza.  </li> <li>Facilita la reutilitzaci\u00f3: classes diferents poden compartir la mateixa interf\u00edcie amb implementacions pr\u00f2pies.</li> </ul>"},{"location":"03-pilars/03-2-abstraccio/#324-abstraccio-i-interficies","title":"3.2.4. Abstracci\u00f3 i interf\u00edcies","text":"<p>L\u2019abstracci\u00f3 s\u2019aplica tamb\u00e9 mitjan\u00e7ant classes abstractes i interf\u00edcies, que defineixen qu\u00e8 pot fer una classe sense especificar com ho fa.  </p> <pre><code>abstract class Vehiculo {\n    public abstract void arranca();  // Nom\u00e9s es defineix el QU\u00c8\n}\n\nclass Coche extends Vehiculo {\n    @Override\n    public void arranca(){           // Es defineix el COM\n        System.out.println(\"El cotxe arranca amb clau o bot\u00f3.\");\n    }\n}\n\nclass Bicicleta extends Vehiculo {\n    @Override\n    public void arranca(){\n        System.out.println(\"La bicicleta arranca amb la for\u00e7a de les cames.\");\n    }\n}\n</code></pre> <p>Cada subclasse implementa la mateixa acci\u00f3 (\u201carrancar\u201d) segons el seu propi comportament, mantenint la mateixa interf\u00edcie.</p>"},{"location":"03-pilars/03-2-abstraccio/#325-exemple-conceptual","title":"3.2.5. Exemple conceptual","text":"<pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502        Vehiculo        \u2502\n           \u2502------------------------\u2502\n           \u2502 + arranca() : void     \u2502  \u2190 Descripci\u00f3 general (abstracci\u00f3)\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502                                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Coche   \u2502                    \u2502 Bicicleta  \u2502\n\u2502----------\u2502                    \u2502------------\u2502\n\u2502 arranca()\u2502                    \u2502 arranca()  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"03-pilars/03-2-abstraccio/#326-abstraccio-vs-encapsulacio","title":"3.2.6. Abstracci\u00f3 vs. Encapsulaci\u00f3","text":"<p>Encara que estan relacionats, abstracci\u00f3 i encapsulaci\u00f3 no s\u00f3n el mateix:</p> Concepte Objectiu Exemple Encapsulaci\u00f3 Amagar les dades internes i protegir-les <code>private int edat;</code> + <code>getEdat()</code> Abstracci\u00f3 Amagar els detalls de la implementaci\u00f3 i mostrar nom\u00e9s les funcionalitats essencials <code>arranca()</code> sense mostrar com funciona el motor <p>L\u2019encapsulaci\u00f3 \u00e9s una t\u00e8cnica per aconseguir l\u2019abstracci\u00f3, mentre que l\u2019abstracci\u00f3 \u00e9s un principi de disseny.</p>"},{"location":"03-pilars/03-2-abstraccio/#327-exemple-del-mon-real","title":"3.2.7. Exemple del m\u00f3n real","text":"<p>En un tel\u00e8fon m\u00f2bil, l\u2019usuari pot fer una foto prement un bot\u00f3: no necessita con\u00e9ixer com la c\u00e0mera ajusta l\u2019exposici\u00f3, la resoluci\u00f3 o el focus. Eixos detalls queden amagats darrere d\u2019una interf\u00edcie simple i abstracta.</p> <p>De la mateixa manera, en OOP, una classe ofereix una interf\u00edcie senzilla i amaga la complexitat interna.</p>"},{"location":"03-pilars/03-2-abstraccio/#328-resum-final","title":"3.2.8. Resum final","text":"Concepte Descripci\u00f3 Exemple Abstracci\u00f3 Amaga detalls no rellevants i ofereix operacions d\u2019alt nivell <code>arranca()</code> encapsula el proc\u00e9s intern Classe abstracta Defineix el qu\u00e8 sense el com <code>abstract void arranca();</code> Interf\u00edcie Contracte d\u2019\u00fas sense implementaci\u00f3 <code>interface Vehiculo { void arranca(); }</code> Benefici Simplificaci\u00f3 i independ\u00e8ncia de la implementaci\u00f3 L\u2019usuari no ha de saber com funciona internament <p>\u201cAbstraure \u00e9s reduir el m\u00f3n a la seua ess\u00e8ncia per poder-lo comprendre i construir-lo millor.\u201d</p>"},{"location":"03-pilars/03-3-1-classes-abstractes/","title":"3.3.1. Classes abstractes","text":"<p>Les classes abstractes s\u00f3n un tipus especial de classes que no es poden instanciar directament. Serveixen com a models o plantilles per a altres classes, definint el comportament general que les subclasses hauran d\u2019implementar.</p> <p>Una classe abstracta pot contenir:</p> <ul> <li>M\u00e8todes abstractes (sense cos), que les subclasses estan obligades a implementar.  </li> <li>M\u00e8todes concrets (amb cos), que poden ser reutilitzats o sobreescrits.  </li> <li>Atributs comuns, accessibles per totes les subclasses.</li> </ul>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3311-exemple-basic","title":"3.3.1.1. Exemple b\u00e0sic","text":"<pre><code>public abstract class Vehiculo {\n    public abstract void arranca(); // m\u00e8tode abstracte\n}\n</code></pre> <p>Aquesta classe no es pot utilitzar per crear objectes directament:</p> <pre><code>// \u274c Error:\nVehiculo v = new Vehiculo(); // No es pot instanciar una classe abstracta\n</code></pre> <p>Per\u00f2 s\u00ed que pot ser base d\u2019altres classes que implementen els m\u00e8todes abstractes:</p> <pre><code>public class VehiculoElectrico extends Vehiculo {\n    @Override\n    public void arranca(){\n        System.out.println(\"El vehicle el\u00e8ctric arranca silenciosament.\");\n    }\n}\n\npublic class VehiculoGasolina extends Vehiculo {\n    @Override\n    public void arranca(){\n        System.out.println(\"El vehicle de gasolina arranca amb soroll del motor.\");\n    }\n}\n</code></pre>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3312-comportament","title":"3.3.1.2. Comportament","text":"<p>Quan una classe hereta d\u2019una classe abstracta, ha d\u2019implementar tots els m\u00e8todes abstractes o, en cas contrari, tamb\u00e9 s\u2019ha de declarar com a abstracta.</p> <pre><code>public abstract class Maquina {\n    public abstract void iniciar();\n}\n\npublic class Impresora extends Maquina {\n    @Override\n    public void iniciar(){\n        System.out.println(\"La impressora est\u00e0 llesta per imprimir.\");\n    }\n}\n</code></pre> <p>Aix\u00ed, <code>Impresora</code> proporciona la seua pr\u00f2pia implementaci\u00f3 del m\u00e8tode <code>iniciar()</code>.</p>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3313-classes-abstractes-amb-atributs-i-metodes-concrets","title":"3.3.1.3. Classes abstractes amb atributs i m\u00e8todes concrets","text":"<p>Les classes abstractes tamb\u00e9 poden definir comportaments comuns a totes les subclasses:</p> <pre><code>public abstract class Animal {\n    protected String nom;\n\n    public Animal(String nom){\n        this.nom = nom;\n    }\n\n    // M\u00e8tode concret\n    public void dormir(){\n        System.out.println(nom + \" est\u00e0 dormint...\");\n    }\n\n    // M\u00e8tode abstracte\n    public abstract void ferSo();\n}\n\npublic class Gos extends Animal {\n    public Gos(String nom){ super(nom); }\n\n    @Override\n    public void ferSo(){\n        System.out.println(\"Bup! Bup!\");\n    }\n}\n\npublic class Gat extends Animal {\n    public Gat(String nom){ super(nom); }\n\n    @Override\n    public void ferSo(){\n        System.out.println(\"Miau!\");\n    }\n}\n</code></pre> <p>Eixida del programa:</p> <pre><code>Gos rex = new Gos(\"Rex\");\nrex.dormir();\nrex.ferSo();\n</code></pre> <pre><code>Rex est\u00e0 dormint...\nBup! Bup!\n</code></pre>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3314-comparacio-amb-les-classes-normals","title":"3.3.1.4. Comparaci\u00f3 amb les classes normals","text":"Caracter\u00edstica Classe normal Classe abstracta Es pot instanciar? \u2714\ufe0f S\u00ed \u274c No Pot contindre m\u00e8todes abstractes? \u274c No \u2714\ufe0f S\u00ed Pot contindre m\u00e8todes concrets? \u2714\ufe0f S\u00ed \u2714\ufe0f S\u00ed Pot definir atributs? \u2714\ufe0f S\u00ed \u2714\ufe0f S\u00ed Pot ser superclasse d\u2019altres classes? \u2714\ufe0f S\u00ed \u2714\ufe0f S\u00ed"},{"location":"03-pilars/03-3-1-classes-abstractes/#3315-avantatges-dusar-classes-abstractes","title":"3.3.1.5. Avantatges d\u2019usar classes abstractes","text":"<ul> <li>Centralitzen el comportament com\u00fa: eviten duplicar codi en subclasses.  </li> <li>Forcen la implementaci\u00f3 d\u2019accions essencials en les subclasses.  </li> <li>Permeten combinar codi gen\u00e8ric amb obligacions espec\u00edfiques (barreja de m\u00e8todes concrets i abstractes).  </li> <li>Milloren la coher\u00e8ncia en el disseny d\u2019un conjunt de classes relacionades.</li> </ul>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3316-exemple-uml-textual","title":"3.3.1.6. Exemple UML textual","text":"<pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502        Vehiculo            \u2502\n            \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n            \u2502 + arranca() : void {abstract} \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                                   \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 VehiculoGasolina \u2502             \u2502 VehiculoElectrico \u2502\n\u2502------------------\u2502             \u2502-------------------\u2502\n\u2502 arranca()        \u2502             \u2502 arranca()         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3317-notes-addicionals","title":"3.3.1.7. Notes addicionals","text":"<ul> <li>Si una classe abstracta cont\u00e9 nom\u00e9s m\u00e8todes abstractes, podria substituir-se per una interf\u00edcie.  </li> <li>No obstant aix\u00f2, si combina comportament com\u00fa amb definicions abstractes, \u00e9s preferible mantindre-la com a abstracta.  </li> <li>Les subclasses poden sobreescriure m\u00e8todes concrets de la superclasse si cal un comportament diferent.</li> </ul>"},{"location":"03-pilars/03-3-1-classes-abstractes/#3318-resum-final","title":"3.3.1.8. Resum final","text":"Concepte Descripci\u00f3 Exemple Classe abstracta Classe que no pot ser instanciada i serveix com a model <code>abstract class Vehiculo</code> M\u00e8tode abstracte Declaraci\u00f3 sense cos que obliga a implementar-lo a les subclasses <code>public abstract void arranca();</code> Subclasse concreta Implementa tots els m\u00e8todes abstractes <code>VehiculoGasolina</code>, <code>VehiculoElectrico</code> Combinaci\u00f3 amb m\u00e8todes concrets Possible, per compartir funcionalitats <code>Animal.dormir()</code> <p>\u201cLes classes abstractes no s\u00f3n objectes, sin\u00f3 idees que prenen forma a trav\u00e9s de les seues filles.\u201d</p>"},{"location":"03-pilars/03-3-2-interficies/","title":"3.3.2. Interf\u00edcies","text":"<p>Les interf\u00edcies defineixen un conjunt de m\u00e8todes que una classe ha d\u2019implementar. A difer\u00e8ncia de les classes abstractes, no contenen implementacions, nom\u00e9s la definici\u00f3 dels comportaments que les classes oferiran.</p> <p>En altres paraules, una interf\u00edcie \u00e9s com un contracte: estableix qu\u00e8 pot fer una classe, per\u00f2 no com ho fa.</p>"},{"location":"03-pilars/03-3-2-interficies/#3321-caracteristiques-principals","title":"3.3.2.1. Caracter\u00edstiques principals","text":"<ul> <li>Tots els m\u00e8todes d\u2019una interf\u00edcie s\u00f3n, per defecte, <code>public</code> i <code>abstract</code>.  </li> <li>Pot contindre constants (atributs <code>public static final</code>).  </li> <li>Una classe pot implementar diverses interf\u00edcies, la qual cosa permet aconseguir una mena d\u2019her\u00e8ncia m\u00faltiple de comportaments.  </li> <li>Les interf\u00edcies no poden ser instanciades directament.</li> </ul>"},{"location":"03-pilars/03-3-2-interficies/#3322-exemple-basic","title":"3.3.2.2. Exemple b\u00e0sic","text":"<pre><code>interface OpcionRemolque {\n    void engancharRemolque();\n    void desengancharRemolque();\n}\n\npublic class FordConRemolque extends VehiculoGasolina implements OpcionRemolque {\n    @Override\n    public void engancharRemolque(){\n        System.out.println(\"Remolc enganxat.\");\n    }\n\n    @Override\n    public void desengancharRemolque(){\n        System.out.println(\"Remolc desenganxat.\");\n    }\n}\n</code></pre> <p>En aquest exemple:</p> <ul> <li>La interf\u00edcie <code>OpcionRemolque</code> defineix dos m\u00e8todes.  </li> <li>La classe <code>FordConRemolque</code> els implementa, a m\u00e9s d\u2019heretar comportaments de <code>VehiculoGasolina</code>.  </li> <li>Aix\u00f2 permet que qualsevol altre tipus de vehicle que implemente <code>OpcionRemolque</code> puga ser utilitzat de la mateixa manera.</li> </ul>"},{"location":"03-pilars/03-3-2-interficies/#3323-implementacio-multiple","title":"3.3.2.3. Implementaci\u00f3 m\u00faltiple","text":"<p>Una classe pot implementar diverses interf\u00edcies simult\u00e0niament. Aix\u00f2 \u00e9s molt \u00fatil per combinar comportaments sense necessitat d\u2019her\u00e8ncia m\u00faltiple.</p> <pre><code>interface GPS {\n    void mostrarRuta(String desti);\n}\n\ninterface Musica {\n    void reproducirCancion(String titulo);\n}\n\nclass CocheInteligente implements GPS, Musica {\n    public void mostrarRuta(String desti){\n        System.out.println(\"Mostrant la ruta cap a \" + desti);\n    }\n\n    public void reproducirCancion(String titulo){\n        System.out.println(\"Reproduint: \" + titulo);\n    }\n}\n</code></pre> <p>Aix\u00ed, <code>CocheInteligente</code> pot ser utilitzat com a <code>GPS</code> o com a <code>Musica</code> segons el context, gr\u00e0cies al polimorfisme d\u2019interf\u00edcies.</p>"},{"location":"03-pilars/03-3-2-interficies/#3324-interficies-amb-constants","title":"3.3.2.4. Interf\u00edcies amb constants","text":"<p>Les interf\u00edcies tamb\u00e9 poden definir constants, que s\u00f3n per defecte <code>public static final</code>.</p> <pre><code>interface Configuracio {\n    int MAX_VELOCITAT = 120;\n}\n</code></pre> <p>Aquestes constants poden ser utilitzades per qualsevol classe que implemente o fa\u00e7a refer\u00e8ncia a la interf\u00edcie:</p> <pre><code>class Moto implements Configuracio {\n    void comprovarLimit(int velocitat){\n        if (velocitat &gt; MAX_VELOCITAT)\n            System.out.println(\"Supera el l\u00edmit legal!\");\n    }\n}\n</code></pre>"},{"location":"03-pilars/03-3-2-interficies/#3325-comparacio-entre-interficies-i-classes-abstractes","title":"3.3.2.5. Comparaci\u00f3 entre interf\u00edcies i classes abstractes","text":"Caracter\u00edstica Interf\u00edcie Classe abstracta Instanciable? \u274c No \u274c No Cont\u00e9 m\u00e8todes amb cos? \u2705 (des de Java 8 amb <code>default</code>) \u2705 S\u00ed Cont\u00e9 atributs? \u2705 Nom\u00e9s constants (<code>static final</code>) \u2705 Variables normals Her\u00e8ncia m\u00faltiple? \u2705 S\u00ed (una classe pot implementar-ne diverses) \u274c Nom\u00e9s una superclasse Paraula clau <code>implements</code> <code>extends</code> Prop\u00f2sit principal Definir un contracte d\u2019\u00fas Definir comportament parcial o base comuna"},{"location":"03-pilars/03-3-2-interficies/#3326-interficies-amb-metodes-default-i-static-java-8","title":"3.3.2.6. Interf\u00edcies amb m\u00e8todes <code>default</code> i <code>static</code> (Java 8+)","text":"<p>A partir de Java 8, les interf\u00edcies poden incloure m\u00e8todes amb implementaci\u00f3 mitjan\u00e7ant la paraula clau <code>default</code>.</p> <p>Aix\u00f2 permet afegir funcionalitats noves a les interf\u00edcies sense trencar el codi existent.</p> <pre><code>interface Reproductor {\n    void play();\n\n    default void stop(){\n        System.out.println(\"Reproductor aturat.\");\n    }\n\n    static void info(){\n        System.out.println(\"Interf\u00edcie Reproductor v1.0\");\n    }\n}\n</code></pre> <p>Una classe que implemente aquesta interf\u00edcie pot utilitzar el m\u00e8tode <code>stop()</code> directament sense haver de redefinir-lo.</p>"},{"location":"03-pilars/03-3-2-interficies/#3327-exemple-uml-textual","title":"3.3.2.7. Exemple UML textual","text":"<pre><code>               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502     OpcionRemolque    \u2502\n               \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n               \u2502 + engancharRemolque() \u2502\n               \u2502 + desengancharRemolque() \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502   FordConRemolque     \u2502\n                \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n                \u2502 + engancharRemolque() \u2502\n                \u2502 + desengancharRemolque() \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"03-pilars/03-3-2-interficies/#3328-avantatges-de-lus-dinterficies","title":"3.3.2.8. Avantatges de l\u2019\u00fas d\u2019interf\u00edcies","text":"<ul> <li>Flexibilitat: permet combinar funcionalitats sense her\u00e8ncia m\u00faltiple.  </li> <li>Polimorfisme: diferents classes poden ser utilitzades indistintament si implementen la mateixa interf\u00edcie.  </li> <li>Extensibilitat: es poden afegir nous comportaments sense modificar el codi existent.  </li> <li>Independ\u00e8ncia: les interf\u00edcies redueixen el grau d\u2019acoblament entre classes.</li> </ul>"},{"location":"03-pilars/03-3-2-interficies/#3329-resum-final","title":"3.3.2.9. Resum final","text":"Concepte Descripci\u00f3 Exemple Interf\u00edcie Contracte que defineix m\u00e8todes sense implementaci\u00f3 <code>interface OpcionRemolque</code> Implementaci\u00f3 Classe que d\u00f3na cos als m\u00e8todes de la interf\u00edcie <code>class FordConRemolque implements OpcionRemolque</code> M\u00e8todes <code>default</code> Permeten afegir implementacions opcionals <code>default void stop()</code> Polimorfisme Diverses classes poden compartir el mateix tipus d\u2019interf\u00edcie <code>GPS g = new CocheInteligente();</code> <p>\u201cLes interf\u00edcies s\u00f3n ponts conceptuals que connecten idees distintes sota una mateixa forma d\u2019\u00fas.\u201d</p>"},{"location":"03-pilars/03-3-herencia/","title":"3.3. Her\u00e8ncia","text":"<p>La her\u00e8ncia \u00e9s el tercer pilar fonamental de la programaci\u00f3 orientada a objectes. Permet crear noves classes a partir d\u2019altres ja existents, heretant-ne atributs i m\u00e8todes, i afegint-hi o modificant-hi funcionalitats segons convinga.</p> <p>Gr\u00e0cies a la her\u00e8ncia, es pot reutilitzar codi i evitar la duplicaci\u00f3, mantenint una jerarquia l\u00f2gica que reflectix relacions del tipus \u201c\u00e9s un\u201d (is-a).</p>"},{"location":"03-pilars/03-3-herencia/#331-principi-basic","title":"3.3.1. Principi b\u00e0sic","text":"<p>Quan una classe deriva d\u2019una altra, la nova classe hereta totes les caracter\u00edstiques de la seua antecessora, llevat dels elements declarats com a <code>private</code>. La classe base s\u2019anomena superclasse i la que hereta, subclasse.</p> <pre><code>public class Vehiculo {\n    protected int km_totales;\n    private String num_bastidor;\n}\n\npublic class Coche extends Vehiculo {\n    int num_pasajeros;\n}\n\npublic class Camion extends Vehiculo {\n    void soltarCaja(){\n        System.out.println(\"Caixa desenganxada.\");\n    }\n}\n</code></pre> <p>Ac\u00ed, <code>Coche</code> i <code>Camion</code> hereten els atributs i m\u00e8todes p\u00fablics i protegits de <code>Vehiculo</code>, com ara <code>km_totales</code>. L\u2019atribut <code>num_bastidor</code>, en canvi, \u00e9s <code>private</code> i per tant no \u00e9s accessible des de les subclasses.</p>"},{"location":"03-pilars/03-3-herencia/#332-exemple-dus","title":"3.3.2. Exemple d\u2019\u00fas","text":"<pre><code>public class Vehiculo {\n    protected int km_totales;\n    private String num_bastidor;\n\n    public Vehiculo(String bastidor){\n        num_bastidor = bastidor;\n        km_totales = 0;\n    }\n\n    public void avanza(int km){\n        km_totales += km;\n        System.out.println(\"Avan\u00e7ant \" + km + \" km.\");\n    }\n\n    public int getKmTotales(){\n        return km_totales;\n    }\n}\n\npublic class Coche extends Vehiculo {\n    int num_pasajeros;\n\n    public Coche(String bastidor, int pasajeros){\n        super(bastidor); // crida al constructor de la superclasse\n        num_pasajeros = pasajeros;\n    }\n\n    public void mostrarInfo(){\n        System.out.println(\"Coche amb \" + num_pasajeros + \" passatgers.\");\n        System.out.println(\"Quil\u00f2metres totals: \" + km_totales);\n    }\n}\n</code></pre> <p>L\u2019\u00fas de <code>super()</code> permet inicialitzar la part heretada de la classe base. Les subclasses poden afegir nous atributs o m\u00e8todes propis sense duplicar codi.</p>"},{"location":"03-pilars/03-3-herencia/#333-herencia-simple-i-multiple","title":"3.3.3. Her\u00e8ncia simple i m\u00faltiple","text":"<p>En Java, una classe nom\u00e9s pot heretar d\u2019una altra (her\u00e8ncia simple). No obstant aix\u00f2, pot implementar diverses interf\u00edcies, cosa que permet aconseguir un efecte semblant a l\u2019her\u00e8ncia m\u00faltiple.</p> <p>Altres llenguatges, com C++ o Python, s\u00ed que permeten her\u00e8ncia m\u00faltiple directa, encara que pot generar ambig\u00fcitats si no es gestiona correctament.</p> Tipus Exemple Comentari Her\u00e8ncia simple <code>class Coche extends Vehiculo</code> Nom\u00e9s una superclasse directa Her\u00e8ncia m\u00faltiple (indirecta) <code>class Coche implements Motor, Conductor</code> Diverses interf\u00edcies, sense duplicar implementaci\u00f3"},{"location":"03-pilars/03-3-herencia/#334-reutilitzacio-i-especialitzacio","title":"3.3.4. Reutilitzaci\u00f3 i especialitzaci\u00f3","text":"<p>L\u2019her\u00e8ncia permet construir jerarquies que van de classes m\u00e9s generals a classes m\u00e9s espec\u00edfiques. Cada nivell pot afegir o sobreescriure funcionalitats de les classes superiors.</p> <pre><code>class Vehiculo {\n    void arranca(){ System.out.println(\"El vehicle arranca.\"); }\n}\n\nclass Coche extends Vehiculo {\n    void abrirMaletero(){ System.out.println(\"Maleter obert.\"); }\n}\n\nclass Deportivo extends Coche {\n    void activarModoSport(){ System.out.println(\"Mode Sport activat!\"); }\n}\n</code></pre>"},{"location":"03-pilars/03-3-herencia/#jerarquia-uml-textual","title":"Jerarquia UML textual","text":"<pre><code>Vehiculo\n   \u2502\n   \u2514\u2500\u2500 Coche\n          \u2502\n          \u2514\u2500\u2500 Deportivo\n</code></pre> <p>Aquesta jerarquia mostra com <code>Deportivo</code> hereta de <code>Coche</code>, que al seu torn hereta de <code>Vehiculo</code>.</p>"},{"location":"03-pilars/03-3-herencia/#335-lacces-a-la-superclasse","title":"3.3.5. L\u2019acc\u00e9s a la superclasse","text":"<p>La paraula clau <code>super</code> permet:</p> <ul> <li>Invocar el constructor de la classe base.</li> <li>Accedir a m\u00e8todes o atributs de la superclasse que hagen sigut redefinits.</li> </ul> <pre><code>class Vehiculo {\n    void mostrarTipo(){ System.out.println(\"Soc un vehicle.\"); }\n}\n\nclass Coche extends Vehiculo {\n    @Override\n    void mostrarTipo(){\n        super.mostrarTipo();  // Crida al m\u00e8tode de la superclasse\n        System.out.println(\"Concretament, soc un cotxe.\");\n    }\n}\n</code></pre> <p>Eixida:</p> <pre><code>Soc un vehicle.\nConcretament, soc un cotxe.\n</code></pre>"},{"location":"03-pilars/03-3-herencia/#336-avantatges-de-la-herencia","title":"3.3.6. Avantatges de la her\u00e8ncia","text":"<ul> <li>Reutilitzaci\u00f3 de codi: evita duplicar funcionalitats comunes.  </li> <li>Extensibilitat: permet afegir comportaments nous mitjan\u00e7ant subclasses.  </li> <li>Organitzaci\u00f3 jer\u00e0rquica: estructura les classes de forma natural segons el domini.  </li> <li>Polimorfisme: possibilita que objectes de diferents subclasses siguen tractats com a inst\u00e0ncies d\u2019una mateixa superclasse.</li> </ul>"},{"location":"03-pilars/03-3-herencia/#337-riscos-i-bones-practiques","title":"3.3.7. Riscos i bones pr\u00e0ctiques","text":"<p>Encara que la her\u00e8ncia \u00e9s molt \u00fatil, cal utilitzar-la amb criteri:</p> <ul> <li>No abusar-ne per reutilitzar codi quan realment nom\u00e9s caldria composici\u00f3 (veure el principi \u201cpreferix composici\u00f3 a her\u00e8ncia\u201d).  </li> <li>Evitar her\u00e8ncies massa profundes (m\u00e9s de tres nivells), ja que compliquen el manteniment.  </li> <li>Fer que les classes base siguen coherents i estables, per no trencar el funcionament de les subclasses.</li> </ul>"},{"location":"03-pilars/03-3-herencia/#338-resum-comparatiu","title":"3.3.8. Resum comparatiu","text":"Concepte Descripci\u00f3 Exemple Superclasse Classe de la qual s\u2019hereten atributs i m\u00e8todes <code>Vehiculo</code> Subclasse Classe que hereta d\u2019una altra i pot ampliar o modificar funcionalitats <code>Coche</code> <code>super</code> Paraula clau per accedir a la superclasse <code>super.avanza(10);</code> Her\u00e8ncia simple Una \u00fanica classe base <code>class Coche extends Vehiculo</code> Her\u00e8ncia m\u00faltiple Diverses classes base (nom\u00e9s amb interf\u00edcies en Java) <code>implements</code>"},{"location":"03-pilars/03-3-herencia/#339-conclusio","title":"3.3.9. Conclusi\u00f3","text":"<p>La her\u00e8ncia permet modelar relacions jer\u00e0rquiques i promou la reutilitzaci\u00f3 i la coher\u00e8ncia en el disseny del programari. Tanmateix, ha de combinar-se amb altres principis com la composici\u00f3, la cohesi\u00f3 i el polimorfisme per mantenir un codi flexible i sostenible.</p> <p>\u201cHeretar \u00e9s aprendre dels que ja existeixen per construir alguna cosa millor.\u201d</p>"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/","title":"3.4.1. Sobrec\u00e0rrega de m\u00e8todes (ad-hoc)","text":"<p>La sobrec\u00e0rrega de m\u00e8todes \u00e9s una forma de polimorfisme ad-hoc o est\u00e0tic, que ocorre quan dues o m\u00e9s funcions tenen el mateix nom per\u00f2 diferents par\u00e0metres (quantitat o tipus).</p> <p>Aquest mecanisme permet que un mateix m\u00e8tode s\u2019adapte a diferents tipus de dades o situacions sense canviar el seu nom.</p>"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/#3411-exemple-basic","title":"3.4.1.1. Exemple b\u00e0sic","text":"<pre><code>public class Saludo {\n    public void saludar(){\n        System.out.println(\"Hola\");\n    }\n\n    public void saludar(String nombre){\n        System.out.println(\"Hola \" + nombre);\n    }\n}\n</code></pre> <p>En aquest exemple, el m\u00e8tode <code>saludar</code> est\u00e0 sobrec\u00e0rregat:  Una versi\u00f3 mostra un missatge general.  L\u2019altra accepta un par\u00e0metre <code>String</code> per personalitzar el missatge.</p> <p>\u00das:</p> <pre><code>Saludo s = new Saludo();\ns.saludar();           // Hola\ns.saludar(\"Arturo\");   // Hola Arturo\n</code></pre> <p>El compilador selecciona autom\u00e0ticament quina versi\u00f3 del m\u00e8tode s\u2019ha d\u2019executar segons els par\u00e0metres que rep.</p>"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/#3412-regles-de-la-sobrecarrega","title":"3.4.1.2. Regles de la sobrec\u00e0rrega","text":"<p>Perqu\u00e8 dues versions d\u2019un m\u00e8tode siguen v\u00e0lides com a sobrec\u00e0rrega:</p> <ol> <li>Han de tindre diferents par\u00e0metres (nombre, tipus o ordre).  </li> <li>Poden tindre el mateix o diferent tipus de retorn.  </li> <li>No poden diferir nom\u00e9s pel tipus de retorn (el compilador no ho pot distingir).  </li> <li>Poden tindre modificadors d\u2019acc\u00e9s diferents (<code>public</code>, <code>private</code>, etc.).</li> </ol>"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/#3413-exemple-avancat","title":"3.4.1.3. Exemple avan\u00e7at","text":"<pre><code>public class Calculadora {\n\n    int sumar(int a, int b){\n        return a + b;\n    }\n\n    double sumar(double a, double b){\n        return a + b;\n    }\n\n    int sumar(int a, int b, int c){\n        return a + b + c;\n    }\n}\n</code></pre> <p>\u00das:</p> <pre><code>Calculadora calc = new Calculadora();\n\nSystem.out.println(calc.sumar(2, 3));       // 5\nSystem.out.println(calc.sumar(2.5, 3.5));   // 6.0\nSystem.out.println(calc.sumar(1, 2, 3));    // 6\n</code></pre> <p>El mateix nom <code>sumar</code> serveix per a diferents contextos, i el compilador tria la versi\u00f3 correcta abans d\u2019executar el programa.</p>"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/#3414-avantatges","title":"3.4.1.4. Avantatges","text":"<ul> <li>Llegibilitat: el codi \u00e9s m\u00e9s natural i intu\u00eftiu.  </li> <li>Mantenibilitat: s\u2019agrupen operacions semblants sota el mateix nom.  </li> <li>Reutilitzaci\u00f3: permet crear funcions flexibles per a diferents tipus de dades.  </li> <li>Efic\u00e0cia: la resoluci\u00f3 es fa en temps de compilaci\u00f3, no d\u2019execuci\u00f3.</li> </ul>"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/#3415-diferencia-amb-la-sobreescriptura","title":"3.4.1.5. Difer\u00e8ncia amb la sobreescriptura","text":"Aspecte Sobrec\u00e0rrega Sobreescriptura Moment de resoluci\u00f3 Compilaci\u00f3 Execuci\u00f3 Classes implicades Mateixa classe Superclasse i subclasse Objectiu Variar els par\u00e0metres Canviar el comportament Paraula clau @Override No s\u2019utilitza S\u2019utilitza Tipus de polimorfisme Est\u00e0tic (ad-hoc) Din\u00e0mic (inherent)"},{"location":"03-pilars/03-4-1-sobrec%C3%A0rrega/#3416-resum","title":"3.4.1.6. Resum","text":"<p>La sobrec\u00e0rrega permet tindre diversos m\u00e8todes amb el mateix nom per realitzar accions similars per\u00f2 amb dades diferents. \u00c9s un dels mecanismes m\u00e9s comuns del polimorfisme est\u00e0tic i millora la claredat del codi.</p> <p>\u201cSobrec\u00e0rrega \u00e9s dir el mateix, per\u00f2 entendre\u2019l segons el context.\u201d</p>"},{"location":"03-pilars/03-4-2-sobreescriptura/","title":"3.4.2. Sobreescriptura de m\u00e8todes (d\u2019inclusi\u00f3)","text":"<p>La sobreescriptura de m\u00e8todes (overriding) \u00e9s una forma de polimorfisme din\u00e0mic, tamb\u00e9 coneguda com a polimorfisme d\u2019inclusi\u00f3. Consisteix a redefinir un m\u00e8tode heretat d\u2019una superclasse en una subclasse per canviar o adaptar el seu comportament.</p> <p>En aquest cas, el m\u00e8tode conserva el mateix nom, tipus de retorn i par\u00e0metres, per\u00f2 el codi del cos \u00e9s diferent. El m\u00e8tode adequat s\u2019executa segons el tipus real de l\u2019objecte en temps d\u2019execuci\u00f3.</p>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3421-exemple-basic","title":"3.4.2.1. Exemple b\u00e0sic","text":"<pre><code>public class VehiculoGasolina {\n    public void arranca(){\n        System.out.println(\"Arrancant amb gasolina...\");\n    }\n}\n\npublic class Motocicleta extends VehiculoGasolina {\n    @Override\n    public void arranca(){\n        System.out.println(\"La moto arranca amb acceleraci\u00f3 suau.\");\n    }\n}\n</code></pre> <p>\u00das:</p> <pre><code>VehiculoGasolina v1 = new VehiculoGasolina();\nMotocicleta m1 = new Motocicleta();\n\nv1.arranca();  // Arrancant amb gasolina...\nm1.arranca();  // La moto arranca amb acceleraci\u00f3 suau.\n</code></pre> <p>Encara que ambd\u00f3s objectes tenen el mateix m\u00e8tode <code>arranca()</code>, cadascun executa la seua pr\u00f2pia versi\u00f3 segons el tipus real de l\u2019objecte.</p>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3422-polimorfisme-amb-sobreescriptura","title":"3.4.2.2. Polimorfisme amb sobreescriptura","text":"<p>Tamb\u00e9 es pot fer servir una refer\u00e8ncia de la superclasse per apuntar a una inst\u00e0ncia de la subclasse:</p> <pre><code>VehiculoGasolina v2 = new Motocicleta();\nv2.arranca();  // La moto arranca amb acceleraci\u00f3 suau.\n</code></pre> <p>En aquest cas, el tipus de la variable (<code>VehiculoGasolina</code>) \u00e9s de la superclasse, per\u00f2 el m\u00e8tode que s\u2019executa \u00e9s el de la subclasse (<code>Motocicleta</code>). Aquest mecanisme s\u2019anomena enlla\u00e7 din\u00e0mic o polimorfisme d\u2019execuci\u00f3.</p>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3423-regles-de-la-sobreescriptura","title":"3.4.2.3. Regles de la sobreescriptura","text":"<p>Perqu\u00e8 una sobreescriptura siga v\u00e0lida, cal complir aquestes condicions:</p> <ol> <li>El m\u00e8tode de la subclasse ha de tindre el mateix nom, tipus de retorn i par\u00e0metres.  </li> <li>Ha de tindre una igual o major visibilitat (p. ex., <code>protected</code> \u2192 <code>public</code>).  </li> <li>No pot reduir l\u2019\u00e0mbit d\u2019excepcions declarades.  </li> <li>No pot sobreescriure m\u00e8todes declarats com <code>final</code>, <code>static</code> o <code>private</code>.  </li> <li>\u00c9s recomanable usar l\u2019anotaci\u00f3 <code>@Override</code> per indicar expl\u00edcitament la sobreescriptura.</li> </ol>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3424-exemple-avancat","title":"3.4.2.4. Exemple avan\u00e7at","text":"<pre><code>class Empleat {\n    public void treballar(){\n        System.out.println(\"L'empleat est\u00e0 treballant.\");\n    }\n}\n\nclass Programador extends Empleat {\n    @Override\n    public void treballar(){\n        System.out.println(\"El programador escriu codi Java.\");\n    }\n}\n\nclass Dissenyador extends Empleat {\n    @Override\n    public void treballar(){\n        System.out.println(\"El dissenyador crea interf\u00edcies visuals.\");\n    }\n}\n</code></pre> <p>\u00das:</p> <pre><code>Empleat e1 = new Programador();\nEmpleat e2 = new Dissenyador();\n\ne1.treballar(); // El programador escriu codi Java.\ne2.treballar(); // El dissenyador crea interf\u00edcies visuals.\n</code></pre> <p>Encara que <code>e1</code> i <code>e2</code> s\u00f3n del tipus <code>Empleat</code>, cada un crida al seu m\u00e8tode concret segons la classe real. Aix\u00f2 \u00e9s polimorfisme per sobreescriptura.</p>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3425-comparacio-uml-textual","title":"3.4.2.5. Comparaci\u00f3 UML textual","text":"<pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502   VehiculoGasolina \u2502\n            \u2502--------------------\u2502\n            \u2502 + arranca()        \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502     Motocicleta       \u2502\n           \u2502-----------------------\u2502\n           \u2502 + arranca() {override}\u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3426-avantatges-de-la-sobreescriptura","title":"3.4.2.6. Avantatges de la sobreescriptura","text":"<ul> <li>Personalitzaci\u00f3: cada subclasse pot redefinir comportaments adaptats al seu context.  </li> <li>Reutilitzaci\u00f3: s\u2019aprofita el codi com\u00fa de la superclasse i nom\u00e9s es modifica el necessari.  </li> <li>Extensibilitat: permet afegir nous tipus sense alterar el codi existent.  </li> <li>Polimorfisme: les subclasses poden ser utilitzades de manera uniforme com a objectes de la superclasse.</li> </ul>"},{"location":"03-pilars/03-4-2-sobreescriptura/#3427-diferencia-amb-la-sobrecarrega","title":"3.4.2.7. Difer\u00e8ncia amb la sobrec\u00e0rrega","text":"Aspecte Sobreescriptura Sobrec\u00e0rrega Classes implicades Superclasse i subclasse Mateixa classe Moment de resoluci\u00f3 Execuci\u00f3 Compilaci\u00f3 Par\u00e0metres Id\u00e8ntics Diferents Objectiu Canviar el comportament Variar els arguments Paraula clau @Override Obligat\u00f2ria (recomanada) No s\u2019utilitza"},{"location":"03-pilars/03-4-2-sobreescriptura/#3428-resum-final","title":"3.4.2.8. Resum final","text":"Concepte Descripci\u00f3 Exemple Sobreescriptura Redefinici\u00f3 d\u2019un m\u00e8tode heretat per canviar-ne el comportament <code>Motocicleta.arranca()</code> @Override Assegura que el m\u00e8tode existeix a la superclasse <code>@Override public void treballar()</code> Polimorfisme din\u00e0mic Executa el m\u00e8tode segons el tipus real de l\u2019objecte <code>Empleat e = new Programador(); e.treballar();</code> <p>\u201cLa sobreescriptura dona veu pr\u00f2pia a all\u00f2 que hereta, permetent que cada objecte parle amb el seu to.\u201d</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/","title":"3.4.3. Variables polim\u00f2rfiques","text":"<p>Una variable polim\u00f2rfica \u00e9s una refer\u00e8ncia d\u2019un tipus general (com una superclasse o interf\u00edcie) que pot apuntar a objectes de diferents subclasses. Aquest concepte \u00e9s fonamental per a entendre el polimorfisme din\u00e0mic i permet escriure programes m\u00e9s flexibles, escalables i mantenibles.</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3431-exemple-basic","title":"3.4.3.1. Exemple b\u00e0sic","text":"<pre><code>class Vehiculo {\n    void arranca(){\n        System.out.println(\"El vehicle s'ha posat en marxa.\");\n    }\n}\n\nclass VehiculoGasolina extends Vehiculo {\n    @Override\n    void arranca(){\n        System.out.println(\"El vehicle de gasolina arranca amb motor t\u00e8rmic.\");\n    }\n}\n\nclass Motocicleta extends Vehiculo {\n    @Override\n    void arranca(){\n        System.out.println(\"La motocicleta arranca amb acceleraci\u00f3 suau.\");\n    }\n}\n</code></pre> <p>\u00das:</p> <pre><code>Vehiculo v1 = new VehiculoGasolina();\nVehiculo v2 = new Motocicleta();\n\nv1.arranca(); // El vehicle de gasolina arranca amb motor t\u00e8rmic.\nv2.arranca(); // La motocicleta arranca amb acceleraci\u00f3 suau.\n</code></pre> <p>Tot i que <code>v1</code> i <code>v2</code> s\u00f3n variables de tipus <code>Vehiculo</code>, el m\u00e8tode que s\u2019executa dep\u00e8n del tipus real de l\u2019objecte, no del tipus de la refer\u00e8ncia. Aix\u00f2 \u00e9s polimorfisme d\u2019execuci\u00f3.</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3432-funcionament-intern","title":"3.4.3.2. Funcionament intern","text":"<p>Quan el compilador troba una crida a un m\u00e8tode polim\u00f2rfic, no sap quina versi\u00f3 ha d\u2019executar fins que l\u2019objecte concret est\u00e0 disponible en temps d\u2019execuci\u00f3. El sistema utilitza una taula virtual (vtable) per decidir quina implementaci\u00f3 invocar.</p> <p>Aix\u00f2 permet que una mateixa refer\u00e8ncia (<code>Vehiculo</code>) puga apuntar a objectes molt diferents (<code>Motocicleta</code>, <code>Coche</code>, <code>Cami\u00f3</code>, etc.), sempre que compartisquen una interf\u00edcie comuna.</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3433-exemple-amb-colleccions","title":"3.4.3.3. Exemple amb col\u00b7leccions","text":"<p>El polimorfisme \u00e9s especialment \u00fatil quan treballem amb llistes o arrays d\u2019objectes de tipus general.</p> <pre><code>Vehiculo[] garatge = {\n    new VehiculoGasolina(),\n    new Motocicleta(),\n    new Vehiculo()\n};\n\nfor (Vehiculo v : garatge){\n    v.arranca();\n}\n</code></pre> <p>Eixida:</p> <pre><code>El vehicle de gasolina arranca amb motor t\u00e8rmic.\nLa motocicleta arranca amb acceleraci\u00f3 suau.\nEl vehicle s'ha posat en marxa.\n</code></pre> <p>Cada element crida al seu propi m\u00e8tode <code>arranca()</code>, gr\u00e0cies al mecanisme de enlla\u00e7 din\u00e0mic.</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3434-exemple-amb-interficies","title":"3.4.3.4. Exemple amb interf\u00edcies","text":"<p>Tamb\u00e9 es pot aplicar a interf\u00edcies, cosa que permet treballar amb diferents tipus d\u2019objectes que compartixen una mateixa funcionalitat.</p> <pre><code>interface Figura {\n    double area();\n}\n\nclass Cercle implements Figura {\n    double radi;\n    Cercle(double r){ radi = r; }\n    public double area(){ return Math.PI * radi * radi; }\n}\n\nclass Quadrat implements Figura {\n    double costat;\n    Quadrat(double c){ costat = c; }\n    public double area(){ return costat * costat; }\n}\n\npublic class Prova {\n    public static void main(String[] args){\n        Figura f1 = new Cercle(2);\n        Figura f2 = new Quadrat(3);\n\n        System.out.println(f1.area()); // 12.566\n        System.out.println(f2.area()); // 9.0\n    }\n}\n</code></pre> <p>Aix\u00ed, la variable <code>Figura</code> pot referir-se a objectes de tipus <code>Cercle</code> o <code>Quadrat</code>, i cada un respon segons la seua pr\u00f2pia implementaci\u00f3.</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3435-uml-textual","title":"3.4.3.5. UML textual","text":"<pre><code>            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502  Vehiculo  \u2502\n            \u2502-------------\u2502\n            \u2502 + arranca() \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502VehiculoGasolina\u2502      \u2502  Motocicleta   \u2502\n\u2502----------------\u2502      \u2502----------------\u2502\n\u2502 + arranca()    \u2502      \u2502 + arranca()    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Les fletxes representen la relaci\u00f3 d\u2019her\u00e8ncia: les subclasses poden ser utilitzades com si foren la superclasse <code>Vehiculo</code>.</p>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3436-avantatges-de-les-variables-polimorfiques","title":"3.4.3.6. Avantatges de les variables polim\u00f2rfiques","text":"<ul> <li>Flexibilitat: permet escriure codi que funcione amb diferents tipus d\u2019objectes.  </li> <li>Extensibilitat: es poden afegir noves subclasses sense modificar el codi existent.  </li> <li>Reutilitzaci\u00f3: evita duplicar estructures de control (<code>if</code>, <code>switch</code>) per cada tipus concret.  </li> <li>Independ\u00e8ncia del tipus concret: el codi treballa amb la interf\u00edcie comuna, no amb la implementaci\u00f3.</li> </ul>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3437-limitacions-i-conversio-de-tipus","title":"3.4.3.7. Limitacions i conversi\u00f3 de tipus","text":"<p>Les variables polim\u00f2rfiques nom\u00e9s poden accedir als m\u00e8todes visibles per al tipus de refer\u00e8ncia.</p> <pre><code>Vehiculo v = new Motocicleta();\nv.arranca();        // OK\nv.toString();       // OK (heretat de Object)\n// v.revoluciona(); // \u274c Error si no est\u00e0 definit a Vehiculo\n</code></pre> <p>Per accedir a funcionalitats espec\u00edfiques de la subclasse, \u00e9s necessari fer un c\u00e0sting:</p> <pre><code>Motocicleta m = (Motocicleta) v;\nm.revoluciona(); // Ara s\u00ed\n</code></pre>"},{"location":"03-pilars/03-4-3-variables-polimorfes/#3438-resum-final","title":"3.4.3.8. Resum final","text":"Concepte Descripci\u00f3 Exemple Variable polim\u00f2rfica Refer\u00e8ncia de superclasse que pot apuntar a subclasses <code>Vehiculo v = new Motocicleta();</code> Enlla\u00e7 din\u00e0mic Determinaci\u00f3 del m\u00e8tode real en temps d\u2019execuci\u00f3 <code>v.arranca();</code> \u00das com\u00fa Iterar col\u00b7leccions d\u2019objectes diferents amb un tipus com\u00fa <code>for (Vehiculo v : garatge)</code> <p>\u201cEl veritable poder del polimorfisme no est\u00e0 en crear objectes diferents, sin\u00f3 en poder tractar-los com si foren el mateix.\u201d</p>"},{"location":"03-pilars/03-4-polimorfisme/","title":"3.4. Polimorfisme","text":"<p>El polimorfisme \u00e9s el quart pilar fonamental de la programaci\u00f3 orientada a objectes. La paraula prov\u00e9 del grec poly (molts) i morph\u00e9 (formes), i fa refer\u00e8ncia a la capacitat que tenen els objectes o m\u00e8todes de prendre formes diferents segons el context.</p> <p>En OOP, el polimorfisme permet utilitzar el mateix nom per a operacions que actuen de manera diferent segons el tipus d\u2019objecte o el nombre i tipus de par\u00e0metres.</p>"},{"location":"03-pilars/03-4-polimorfisme/#341-tipus-de-polimorfisme","title":"3.4.1. Tipus de polimorfisme","text":"<p>Hi ha dos grans tipus de polimorfisme:</p> Tipus Descripci\u00f3 Exemple De compilaci\u00f3 (est\u00e0tic) Es resol durant la compilaci\u00f3. Basat en la sobrec\u00e0rrega de m\u00e8todes. <code>sumar(int, int)</code> i <code>sumar(double, double)</code> D\u2019execuci\u00f3 (din\u00e0mic) Es resol durant l\u2019execuci\u00f3. Basat en la sobreescriptura i l\u2019\u00fas de variables polim\u00f2rfiques. <code>animal.ferSo()</code> pot invocar <code>Gos.ferSo()</code> o <code>Gat.ferSo()</code>"},{"location":"03-pilars/03-4-polimorfisme/#342-sobrecarrega-de-metodes-polimorfisme-estatic","title":"3.4.2. Sobrec\u00e0rrega de m\u00e8todes (polimorfisme est\u00e0tic)","text":"<p>La sobrec\u00e0rrega ocorre quan dues o m\u00e9s funcions o m\u00e8todes tenen el mateix nom per\u00f2 diferents par\u00e0metres (nombre o tipus). El compilador determina quina versi\u00f3 utilitzar segons els arguments passats.</p> <pre><code>class Calculadora {\n    int sumar(int a, int b){\n        return a + b;\n    }\n\n    double sumar(double a, double b){\n        return a + b;\n    }\n\n    int sumar(int a, int b, int c){\n        return a + b + c;\n    }\n}\n</code></pre> <p>\u00das:</p> <pre><code>Calculadora c = new Calculadora();\nSystem.out.println(c.sumar(2, 3));       // Crida a sumar(int, int)\nSystem.out.println(c.sumar(2.5, 3.5));   // Crida a sumar(double, double)\nSystem.out.println(c.sumar(1, 2, 3));    // Crida a sumar(int, int, int)\n</code></pre> <p>El m\u00e8tode <code>sumar</code> adopta tres formes distintes, depenent dels par\u00e0metres. Aix\u00f2 \u00e9s un exemple de polimorfisme de compilaci\u00f3.</p>"},{"location":"03-pilars/03-4-polimorfisme/#343-sobreescriptura-de-metodes-polimorfisme-dinamic","title":"3.4.3. Sobreescriptura de m\u00e8todes (polimorfisme din\u00e0mic)","text":"<p>La sobreescriptura permet que una subclasse redefinisca un m\u00e8tode de la seua superclasse amb el mateix nom, tipus de retorn i par\u00e0metres. El m\u00e8tode adequat s\u2019executa segons el tipus real de l\u2019objecte, encara que la refer\u00e8ncia siga de la superclasse.</p> <pre><code>class Animal {\n    void ferSo(){\n        System.out.println(\"So gen\u00e8ric d\u2019animal.\");\n    }\n}\n\nclass Gos extends Animal {\n    @Override\n    void ferSo(){\n        System.out.println(\"Bup! Bup!\");\n    }\n}\n\nclass Gat extends Animal {\n    @Override\n    void ferSo(){\n        System.out.println(\"Miau!\");\n    }\n}\n</code></pre> <p>\u00das:</p> <pre><code>Animal a1 = new Gos();\nAnimal a2 = new Gat();\n\na1.ferSo(); // Bup! Bup!\na2.ferSo(); // Miau!\n</code></pre> <p>Encara que les refer\u00e8ncies s\u00f3n d\u2019<code>Animal</code>, el m\u00e8tode que s\u2019executa correspon al tipus real (<code>Gos</code> o <code>Gat</code>). Aquest comportament s\u2019anomena enlla\u00e7 din\u00e0mic o polimorfisme d\u2019execuci\u00f3.</p>"},{"location":"03-pilars/03-4-polimorfisme/#344-variables-polimorfiques","title":"3.4.4. Variables polim\u00f2rfiques","text":"<p>Una variable polim\u00f2rfica \u00e9s una refer\u00e8ncia d\u2019una classe pare que pot apuntar a objectes de qualsevol de les seues subclasses. Aix\u00f2 permet escriure codi m\u00e9s flexible i reutilitzable.</p> <pre><code>Animal a;\n\na = new Gos();\na.ferSo(); // \"Bup! Bup!\"\n\na = new Gat();\na.ferSo(); // \"Miau!\"\n</code></pre> <p>Aquest mecanisme \u00e9s essencial en molts dissenys orientats a objectes, ja que permet tractar col\u00b7leccions d\u2019objectes heterogenis de manera uniforme.</p>"},{"location":"03-pilars/03-4-polimorfisme/#345-polimorfisme-i-interficies","title":"3.4.5. Polimorfisme i interf\u00edcies","text":"<p>Les interf\u00edcies potencien encara m\u00e9s el polimorfisme, ja que una mateixa refer\u00e8ncia pot apuntar a qualsevol classe que les implemente.</p> <pre><code>interface Figura {\n    double area();\n}\n\nclass Cercle implements Figura {\n    double radi;\n    Cercle(double r){ radi = r; }\n    public double area(){ return Math.PI * radi * radi; }\n}\n\nclass Quadrat implements Figura {\n    double costat;\n    Quadrat(double c){ costat = c; }\n    public double area(){ return costat * costat; }\n}\n</code></pre> <p>\u00das:</p> <pre><code>Figura f1 = new Cercle(2.0);\nFigura f2 = new Quadrat(3.0);\n\nSystem.out.println(f1.area()); // 12.566...\nSystem.out.println(f2.area()); // 9.0\n</code></pre> <p>Amb una mateixa variable (<code>Figura</code>) podem treballar amb diferents formes (cercle, quadrat, etc.), sense modificar el codi.</p>"},{"location":"03-pilars/03-4-polimorfisme/#346-exemple-uml-textual","title":"3.4.6. Exemple UML textual","text":"<pre><code>             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2502   Animal     \u2502\n             \u2502--------------\u2502\n             \u2502 + ferSo()    \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Gos     \u2502            \u2502    Gat       \u2502\n\u2502-----------\u2502            \u2502--------------\u2502\n\u2502 + ferSo() \u2502            \u2502 + ferSo()    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"03-pilars/03-4-polimorfisme/#347-avantatges-del-polimorfisme","title":"3.4.7. Avantatges del polimorfisme","text":"<ul> <li>Flexibilitat: el codi pot treballar amb tipus generals i adaptar-se a nous tipus sense canvis.  </li> <li>Reutilitzaci\u00f3: facilita l\u2019\u00fas d\u2019interf\u00edcies i classes abstractes.  </li> <li>Mantenibilitat: redueix la necessitat de condicions <code>if</code> o <code>switch</code> per distingir tipus.  </li> <li>Extensibilitat: permet afegir nous comportaments sense alterar el codi existent.</li> </ul>"},{"location":"03-pilars/03-4-polimorfisme/#348-resum-comparatiu","title":"3.4.8. Resum comparatiu","text":"Tipus Moment de resoluci\u00f3 Basat en Exemple Sobrec\u00e0rrega Compilaci\u00f3 Signatura del m\u00e8tode <code>sumar(int, int)</code> i <code>sumar(double, double)</code> Sobreescriptura Execuci\u00f3 Tipus real de l\u2019objecte <code>animal.ferSo()</code> Variables polim\u00f2rfiques Execuci\u00f3 Refer\u00e8ncies de superclasse o interf\u00edcie <code>Figura f = new Cercle();</code>"},{"location":"03-pilars/03-4-polimorfisme/#349-conclusio","title":"3.4.9. Conclusi\u00f3","text":"<p>El polimorfisme \u00e9s el principi que connecta la jerarquia de classes amb la flexibilitat del codi. Permet que diferents objectes responguen al mateix missatge de manera adaptada al seu tipus concret.</p> <p>\u201cEl polimorfisme \u00e9s l\u2019art de dir una sola cosa i obtindre moltes respostes.\u201d</p>"}]}